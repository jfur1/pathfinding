{"version":3,"sources":["pathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.js","algorithms/astar.js","algorithms/unweightedSearch.js","pathfindingVisualizer/pathfindingVisualizer.jsx","navbar.jsx","App.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","type","g","h","f","direction","weight","status","id","className","Component","dijkstra","grid","start","goal","visited","frontier","nodes","node","push","getNodes","length","sortNodes","shift","Infinity","isVisited","updateNeighborCosts","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getNeighbors","previousNode","getPath","path","tmpNode","unshift","closestNode","index","i","splice","updateNeighbors","target","heuristic","coords","split","x","parseInt","y","toString","updateNode","tmpTarget","trueStart","trueTarget","startCoords","targetCoords","nodeAx","nodeAy","nodeBx","nodeBy","getPathCost","nodeAcoords","map","nodeBcoords","delta_x","Math","abs","delta_y","manhattanDistance","dist","unweightedSearch","explored","algoName","structure","pop","forEach","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","PathfindingVisualizer","initGrid","tmpRow","nodeId","newNode","state","mouseDown","algoFinished","currentAlgo","board","setState","newGrid","updateGrid","newNodes","updateNodes","console","log","document","getElementById","disabled","setTimeout","animatePath","algo","innerHTML","Object","keys","astar","getAstarPath","animateSearch","class","onClick","visualizeSearch","clearGrid","rowIdx","nodeIdx","slice","Navbar","value","event","classList","toggle","toggleDropdown","href","selectAlgo","window","onclick","matches","dropdowns","getElementsByClassName","openDropdown","contains","remove","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.d328bde7.chunk.js","sourcesContent":["import React, {Component} from 'react';\nimport './Node.css';\n\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      row,\n      g,\n      h,\n      f,\n      direction,\n      weight,\n      status\n    } = this.props;\n    const type = isFinish\n      ? 'node-finish'\n      : isStart\n      ? 'node-start'\n      : isWall\n      ? 'node-wall'\n      : '';\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${type}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}></div>\n    );\n  }\n}","// Dijkstra's Algorithm:\n//  - Inputs:\n//      - 2D Grid Matrix\n//      - Start Node\n//      - Goal Node\n//  - Output:\n//      - List of nodes representing the shortest possible path, if one exists.\n\nexport function dijkstra(grid, start, goal) {\n    const visited = [];\n    start.g = 0;\n    const frontier = getNodes(grid);\n    while (!!frontier.length) {\n      sortNodes(frontier);\n      // Guarenteed to be next closest node since we've just sorted the unvisited nodes by distance\n      const node = frontier.shift();\n      \n      // Skip checks for any walls\n      if (node.isWall) continue;\n      // If the closest node is infinite distance, then no path exists to our goal\n      if (node.g === Infinity) return visited;\n\n      node.isVisited = true;\n      visited.push(node);\n      if (node === goal) return visited;\n      updateNeighborCosts(node, grid);\n    }\n  }\n  \n  // Sort the nodes by distance\n  function sortNodes(frontier) {\n    frontier.sort((nodeA, nodeB) => nodeA.g - nodeB.g);\n  }\n  \n  function updateNeighborCosts(node, grid) {\n    const unvisitedNeighbors = getNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n      neighbor.g = node.g + 1;\n      neighbor.previousNode = node;\n    }\n  }\n  \n  function getNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n  }\n  \n  function getNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        nodes.push(node);\n      }\n    }\n    return nodes;\n  }\n  \n  // Backtracks from the goal to find the shortest path.\n\n  export function getPath(goal) {\n    const path = [];\n    let tmpNode = goal;\n    while (tmpNode !== null) {\n      path.unshift(tmpNode);\n      tmpNode = tmpNode.previousNode;\n    }\n    return path;\n  }","// A* Search Algorithm\n//  - Allowable Moves: [N, E, S, W]\n//  - Inputs\n//      - Adjacency Matrix\n//      - Start Node\n//      - Goal Node\n//  - Output:\n//      - Guarenteed shortest possible path\nexport function astar(nodes, start, goal, explored, grid, heuristic){\n    if(!start || !goal || start === goal)\n        return false;\n    nodes[start.id].g = 0;\n    nodes[start.id].f = 0;\n    nodes[start.id].direction = \"N\";\n    let frontier = Object.keys(nodes);\n    console.log(\"frontier:\", frontier)\n    while(frontier.length){\n        // Pop the next closest node off the frontier\n        let node = closestNode(nodes, frontier);\n        // Make sure the node is not a wall\n        while(node.status === \"wall\"  && frontier.length){\n            node = closestNode(nodes, frontier);\n        }\n        if(node.g === Infinity) return false;\n        explored.push(node);\n        node.status = \"visited\";\n        if(node.id === goal.id) return explored;\n\n        updateNeighbors(nodes, node, grid, start, goal, heuristic);\n\n    }\n    \n}\n\nfunction closestNode(nodes, frontier){\n    let node, index;\n    for(let i = 0; i < frontier.length; i++){\n        if(!node || node.f > nodes[frontier[i]].f){\n            node = nodes[frontier[i]];\n            index = i;\n        }\n        else if(node.f === nodes[frontier[i]].f){\n            if(node.h > nodes[frontier[i]].h){\n                node = nodes[frontier[i]];\n                index = i;\n            }\n        }\n    }\n    frontier.splice(index, 1);\n    return node;\n}\n\nfunction updateNeighbors(nodes, node, grid, start, target, heuristic){\n    let neighbors = getNeighbors(node.id, nodes, grid);\n    for(let neighbor of neighbors){\n        if(target){\n            // console.log(\"node:\", node);\n            // console.log(\"neighbor:\", neighbor)\n            updateNode(node, nodes[neighbor], nodes[start.id], nodes[target.id], nodes, grid, heuristic);\n        }\n        else{\n            updateNode(node, nodes[neighbor]);\n        }\n    }\n}\n\nfunction updateNode(node, tmpTarget, trueStart, trueTarget, nodes, grid, heuristic){\n    let path = getPathCost(node, tmpTarget);\n    // If our new target node has no heuristic => Assign to be manhattan distance\n    if(!tmpTarget.h) tmpTarget.h = manhattanDistance(tmpTarget, trueTarget);\n    let dist = node.g + tmpTarget.weight + path[0];\n    if(dist < tmpTarget.g){\n        tmpTarget.g = dist;\n        tmpTarget.f = tmpTarget.g + tmpTarget.h\n        tmpTarget.previousNode = node;\n        tmpTarget.path = path[1];\n        tmpTarget.direction = path[2];\n    }\n}\n\nfunction getNeighbors(id, nodes, grid){\n    let coords = id.split(\"-\");\n    let x = parseInt(coords[0]);\n    let y = parseInt(coords[1]);\n    let neighbors = [];\n    let neighbor;\n    // North\n    if(grid[x-1] && grid[x-1][y]){\n        neighbor = `${(x-1).toString()}-${y.toString()}`;\n        if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n    }\n    // South\n    if(grid[x+1] && grid[x+1][y]){\n        neighbor = `${(x+1).toString()}-${y.toString()}`;\n        if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n    }\n    if(grid[x][y-1]){\n        neighbor = `${x.toString()}-${(y - 1).toString()}`;\n        if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n    }\n    if(grid[x][y+1]){\n        neighbor = `${x.toString()}-${(y + 1).toString()}`;\n        if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n    }\n    return neighbors;\n}\n\nfunction getPathCost(nodeA, nodeB){\n    let startCoords = nodeA.id.split(\"-\");\n    let targetCoords = nodeB.id.split(\"-\");\n    let nodeAx = parseInt(startCoords[0]);\n    let nodeAy = parseInt(startCoords[1]);\n    let nodeBx = parseInt(targetCoords[0]);\n    let nodeBy = parseInt(targetCoords[1]);\n    // B is above A\n    if(nodeBx < nodeAx && nodeAy === nodeBy){\n        if(nodeA.direction === \"N\") return [1, [\"f\"], \"N\"];\n        else if(nodeA.direction === \"E\") return [2, [\"l\", \"f\"], \"N\"];\n        else if(nodeA.direction === \"W\") return [2, [\"r\", \"f\"], \"N\"];\n        else if(nodeA.direction === \"S\") return [3, [\"r\", \"r\", \"f\"], \"N\"];\n        else if(nodeA.direction === \"NE\") return [1.5, null, \"N\"];\n        else if(nodeA.direction === \"SE\") return [2.5, null, \"N\"];\n        else if(nodeA.direction === \"NW\") return [1.5, null, \"N\"];\n        else if(nodeA.direction === \"SW\") return [2.5, null, \"N\"];\n    }\n    else if(nodeBx > nodeAx && nodeAy === nodeBy){\n        if(nodeA.direction === \"N\") return [3, [\"r\", \"r\", \"f\"], \"S\"];\n        else if(nodeA.direction === \"E\") return [2, [\"r\", \"f\"], \"S\"];\n        else if(nodeA.direction === \"W\") return [2, [\"l\", \"f\"], \"S\"];\n        else if(nodeA.direction === \"S\") return [1, [\"f\"], \"S\"];\n        else if(nodeA.direction === \"NE\") return [2.5, null, \"S\"];\n        else if(nodeA.direction === \"SE\") return [1.5, null, \"S\"];\n        else if(nodeA.direction === \"NW\") return [2.5, null, \"S\"];\n        else if(nodeA.direction === \"SW\") return [1.5, null, \"S\"];\n    }\n    if(nodeBy < nodeAy && nodeAx === nodeBx){\n        if(nodeA.direction === \"N\") return [2, [\"l\", \"f\"], \"W\"];\n        else if(nodeA.direction === \"E\") return [3, [\"l\", \"l\", \"f\"], \"W\"];\n        else if(nodeA.direction === \"W\") return [1, [\"f\"], \"W\"];\n        else if(nodeA.direction === \"S\") return [2, [\"r\", \"f\"], \"W\"];\n        else if(nodeA.direction === \"NE\") return [2.5, null, \"W\"];\n        else if(nodeA.direction === \"SE\") return [2.5, null, \"W\"];\n        else if(nodeA.direction === \"NW\") return [1.5, null, \"W\"];\n        else if(nodeA.direction === \"SW\") return [1.5, null, \"W\"];\n    }\n    else if(nodeBy > nodeAy && nodeAx === nodeBx){\n        if(nodeA.direction === \"N\") return [2, [\"r\", \"f\"], \"E\"];\n        else if(nodeA.direction === \"E\") return [1, [\"f\"], \"E\"];\n        else if(nodeA.direction === \"W\") return [3, [\"r\",\"r\",\"f\"], \"E\"];\n        else if(nodeA.direction === \"S\") return [2, [\"l\", \"f\"], \"E\"];\n        else if(nodeA.direction === \"NE\") return [1.5, null, \"E\"];\n        else if(nodeA.direction === \"SE\") return [1.5, null, \"E\"];\n        else if(nodeA.direction === \"NW\") return [2.5, null, \"E\"];\n        else if(nodeA.direction === \"SW\") return [2.5, null, \"E\"];\n    }\n}\n\nfunction manhattanDistance(nodeA, nodeB){\n    let nodeAcoords = nodeA.id.split(\"-\").map(x => parseInt(x));\n    let nodeBcoords = nodeB.id.split(\"-\").map(x => parseInt(x));\n    let nodeAx = nodeAcoords[0];\n    let nodeBx = nodeBcoords[0];\n    let nodeAy = nodeAcoords[1];\n    let nodeBy = nodeBcoords[1];\n\n    let delta_x = Math.abs(nodeAx - nodeBx);\n    let delta_y = Math.abs(nodeAy - nodeBy);\n\n    return (delta_x + delta_y);\n}\n\nexport function getAstarPath(goal) {\n    const path = [];\n    let tmpNode = goal;\n    while (tmpNode !== null) {\n      path.unshift(tmpNode);\n      tmpNode = tmpNode.previousNode;\n    }\n    return path;\n  }","export function unweightedSearch(nodes, start, target, explored, grid, algoName){\n    if(!start || !target || start === target)\n        return false;\n    let structure = [nodes[start.id]];\n    let visited = {start: true};\n    while(structure.length){\n        let node = algoName === \"bfs\" ? structure.shift() : structure.pop();\n        explored.push(node);\n        if(algoName === \"dfs\"){\n            visited[node.id] = true;\n        }\n        node.status = \"visited\";\n        if(node.id === target.id){\n            return explored;\n        }\n        let neighbors = getNeighbors(node.id, nodes, grid, algoName);\n        neighbors.forEach(neighbor => {\n           if(!visited[neighbor]){\n               if(algoName === \"bfs\"){\n                   visited[neighbor] = true;\n               }\n               nodes[neighbor].previousNode = node;\n               structure.push(nodes[neighbor]);\n           } \n        });\n    }\n    return false;\n}\n\nfunction getNeighbors(id, nodes, grid, algoName){\n    let coords = id.split(\"-\");\n    let x = parseInt(coords[0]);\n    let y = parseInt(coords[1]);\n    let neighbors = [];\n    let neighbor;\n    if(grid[x-1] && grid[x-1][y]){\n        neighbor = `${(x - 1).toString()}-${y.toString()}`;\n        if(nodes[neighbor].status !== \"wall\"){\n            if(algoName === \"bfs\"){\n                neighbors.push(neighbor);\n            }else{\n                neighbors.unshift(neighbor);\n            }\n        }\n    }\n    if(grid[x][y+1]){\n        neighbor = `${x.toString()}-${(y + 1).toString()}`;\n        if(nodes[neighbor].status !== \"wall\"){\n            if(algoName === \"bfs\"){\n                neighbors.push(neighbor);\n            }else{\n                neighbors.unshift(neighbor);\n            }\n        }\n    }\n    if(grid[x+1] && grid[x+1][y]){\n        neighbor = `${(x + 1).toString()}-${y.toString()}`;\n        if(nodes[neighbor].status !== \"wall\"){\n            if(algoName === \"bfs\"){\n                neighbors.push(neighbor);\n            }else{\n                neighbors.unshift(neighbor);\n            }\n        }\n    }\n    if(grid[x][y-1]){\n        neighbor = `${x.toString()}-${(y - 1).toString()}`;\n        if(nodes[neighbor].status !== \"wall\"){\n            if(algoName === \"bfs\"){\n                neighbors.push(neighbor);\n            }else{\n                neighbors.unshift(neighbor);\n            }\n        }\n    }\n    return neighbors;\n}\n","import React, {Component} from 'react';\nimport Node from './Node/Node';\nimport {dijkstra, getPath} from '../algorithms/dijkstra';\nimport {astar, getAstarPath} from '../algorithms/astar';\nimport './pathfindingVisualizer.css';\nimport {unweightedSearch} from '../algorithms/unweightedSearch';\nimport { nodeName } from 'jquery';\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35;\n\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      nodes: {},\n      mouseDown: false,\n      algoFinished: true,\n      currentAlgo: null,\n      start: null,\n      target: null\n    };\n  }\n\n  componentDidMount() {\n    const board = this.initGrid();\n    this.setState({grid: board[0], nodes: board[1]});\n  }\n\n  onMouseDown(row, col) {\n    const newGrid = updateGrid(this.state.grid, row, col);\n    const newNodes = updateNodes(this.state.nodes, row, col);\n    this.setState({grid: newGrid, nodes: newNodes, mouseDown: true});\n  }\n\n  onMouseEnter(row, col) {\n    if (!this.state.mouseDown) return;\n    const newGrid = updateGrid(this.state.grid, row, col);\n    const newNodes = updateNodes(this.state.nodes, row, col);\n    this.setState({grid: newGrid, nodes: newNodes});\n  }\n\n  onMouseUp() {\n    this.setState({mouseDown: false});\n  }\n\n  animateSearch(visited, path) {\n    if(visited === false){\n      console.log(\"No path found.\")\n      this.algoFinished = true;\n      document.getElementById(\"startButton\").disabled = false;\n      document.getElementById(\"clearGridButton\").disabled = false;\n    }\n    for (let i = 0; i <= visited.length; i++) {\n      if (i === visited.length) {\n        setTimeout(() => {\n          this.animatePath(path);\n        }, 10 * i);\n        return;\n      }\n      // Visited nodes get animated in 10ms intervals\n      setTimeout(() => {\n        const node = visited[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-visited';\n      }, 10 * i);\n    }\n  }\n\n  animatePath(path) {\n    for (let i = 0; i < path.length; i++) {\n      setTimeout(() => {\n        const node = path[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-shortest-path';\n      }, 35 * i);\n    }\n    this.algoFinished = true;\n    document.getElementById(\"startButton\").disabled = false;\n    document.getElementById(\"clearGridButton\").disabled = false;\n    return;\n  }\n\n  visualizeSearch() {\n      const algo = document.getElementById(\"startButton\").innerHTML;\n      if(algo === \"Visualize Algorithm\"){\n        console.log(\"Select an algorithm!\");\n      }\n      else{\n        document.getElementById(\"startButton\").disabled = true;\n        document.getElementById(\"clearGridButton\").disabled = true;\n      }\n      this.algoFinished = false;\n      const {grid, nodes} = this.state;\n      const start = grid[START_NODE_ROW][START_NODE_COL];\n      const goal = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n      var visited = [];\n      var path = [];\n      // Select algo based on start button text\n      if(algo === \"A* Search\"){\n        console.log(nodes);\n        // console.log(\"start:\", start)\n        // console.log(\"start-id:\", start.id)\n        // console.log(\"goal:\", goal)\n        visited = astar(nodes, start, goal, visited, grid, []);\n        path = getAstarPath(goal);\n        console.log(\"Astar Visited:\", visited);\n        console.log(\"Astar Path:\", path);\n        this.animateSearch(visited, path);\n        return;\n      }\n      else if(algo === \"Dijkstra's Algorithm\"){\n        visited = dijkstra(grid, start, goal);\n        path = getPath(goal);\n        console.log(\"Dijkstra Visited:\", visited);\n        console.log(\"Dijkstra Path:\", path);\n        this.animateSearch(visited, path);\n        return;\n      }else if(algo === \"Depth-First-Search\"){\n        visited = unweightedSearch(nodes, start, goal, visited, grid, \"dfs\");\n        path = getPath(goal);\n        console.log(\"DFS Visited:\", visited);\n        console.log(\"DFS Path:\", path);\n        this.animateSearch(visited, path);\n        return;\n      }else if(algo === \"Breadth-First-Search\"){\n        visited = unweightedSearch(nodes, start, goal, visited, grid, \"bfs\");\n        path = getPath(goal);\n        console.log(\"BFS Visited:\", visited);\n        console.log(\"BFS Path:\", path);\n        this.animateSearch(visited, path);\n        return;\n      }\n      return;\n  }\n\n  clearGrid() {\n    if(this.algoFinished){\n      const board = this.initGrid();\n      this.setState({grid: board[0], nodes: board[1]});\n      for(let row = 0; row < 20; row++) {\n        for (let col = 0; col < 50; col++) {\n          if(row === START_NODE_ROW && col === START_NODE_COL){\n            //this.nodes[this.start].status = \"start\"\n            document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n          }\n          else if(row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\n            document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n            //this.target.status = \"target\";\n          }\n          else{\n            //this.nodes[`${row}-${col}`].status = \"unvisited\";\n            document.getElementById(`node-${row}-${col}`).className = 'node';\n          }\n        }\n      }\n    }\n    return;\n  }\n  // Initialize New Grid\n  initGrid = () => {\n    var grid = [];\n    var nodes = {};\n    for (let row = 0; row < 20; row++) {\n      const tmpRow = [];\n      for (let col = 0; col < 50; col++) {\n        var nodeId = `${row}-${col}`, nodeClass, node;\n        var node = newNode(col, row);\n\n        if(row === START_NODE_ROW && col === START_NODE_COL){\n          node.status = \"start\"\n        } \n        else if(row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\n          node.status = \"target\"\n        } \n        else node.status = \"node\"\n\n        tmpRow.push(node);\n        nodes[nodeId] = node;\n      }\n      grid.push(tmpRow);\n    }\n    return [grid, nodes];\n  };\n\n  render() {\n    const {grid, mouseDown, algoFinished} = this.state;\n    let tableHTML = \"\";\n    return (\n      <>\n        \n        <div class=\"board\">\n        <div class=\"center\">\n          <button id=\"startButton\" onClick={() => this.visualizeSearch()}>Visualize Algorithm</button>\n        </div>\n        <div class=\"center\">\n          <button id=\"clearGridButton\" onClick={() => this.clearGrid()}>Clear Grid</button>\n        </div>\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const {row, col, isFinish, isStart, isWall} = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      g = {Infinity}\n                      h = {null}\n                      f = {Infinity}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      mouseDown={mouseDown}\n                      onMouseDown={(row, col) => this.onMouseDown(row, col)}\n                      onMouseEnter={(row, col) => this.onMouseEnter(row, col)}\n                      onMouseUp={() => this.onMouseUp()}\n                      row={row}></Node>\n                      \n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n        </div>\n      </>\n    );\n  }\n}\n\n// Create a new Node\nconst newNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    g: Infinity,\n    h: null,\n    f: Infinity,\n    status: null,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n    weight: 0,\n    id: `${row}-${col}`\n  };\n};\n\n// Update our grid state\nconst updateGrid = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  if(row === START_NODE_ROW && col === START_NODE_COL \n    || row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\n    return grid;\n  }\n  const newNode = {\n    ...node,\n   isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst updateNodes = (nodes, row, col) => {\n  if(row === START_NODE_ROW && col === START_NODE_COL \n    || row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\n    return nodes;\n  }\n  const newNodes = nodes;\n  const node = nodes[`${row}-${col}`];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  if(newNode.isWall) newNode.status = \"wall\";\n  newNodes[`${row}-${col}`] = newNode;\n  return newNodes;\n}","import React, {Component} from 'react';\nimport './navbar.css';\n\nexport default class Navbar extends Component{\n\n    constructor(props){\n        super(props);\n        this.state = {value: props.value};\n    }\n\n    handleChange(event){\n        this.setState({value: event.target.value});\n    }\n    \n    toggleDropdown(){\n        \n        document.getElementById(\"myDropdown\").classList.toggle(\"show\");\n    }\n\n    selectAlgo(id){\n        this.toggleDropdown();\n        document.getElementById(\"startButton\").innerHTML = id;\n        return;\n    }\n\n    render(){\n        return(\n            <div class=\"navbar\">\n                <div class=\"dropdown\">\n                    <button onClick={() => this.toggleDropdown()} class=\"dropbtn\">Select an Algorithm</button>\n                    <div id=\"myDropdown\" class=\"dropdown-content\">\n                        <a href=\"#\" id=\"dijkstraStart\" onClick={() => this.selectAlgo(\"Dijkstra's Algorithm\")}>Dijkstra's Algorithm</a>\n                        <a href=\"#\" id=\"astarStart\" onClick={() => this.selectAlgo(\"A* Search\")}>A* Search</a>\n                        <a href=\"#\" id=\"bfsStart\" onClick={() => this.selectAlgo(\"Breadth-First-Search\")}>BFS</a>\n                        <a href=\"#\" id=\"dfsStart\" onClick={() => this.selectAlgo(\"Depth-First-Search\")}>DFS</a>\n                    </div>\n                </div>\n            </div>\n        )\n    }\n\n}    \n// Close the dropdown menu if the user clicks outside of it\nwindow.onclick = function(event) {\n    if (!event.target.matches('.dropbtn')) {\n    var dropdowns = document.getElementsByClassName(\"dropdown-content\");\n    var i;\n    for (i = 0; i < dropdowns.length; i++) {\n        var openDropdown = dropdowns[i];\n        if (openDropdown.classList.contains('show')) {\n        openDropdown.classList.remove('show');\n        }\n    }\n    }\n}","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './pathfindingVisualizer/pathfindingVisualizer';\nimport Navbar from './navbar';\n\nfunction App() {\n  return (    \n    <div className=\"App\">\n      <Navbar></Navbar>\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div> \n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));"],"sourceRoot":""}