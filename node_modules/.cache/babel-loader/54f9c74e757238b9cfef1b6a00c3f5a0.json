{"ast":null,"code":"import { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/pathfindingVisualizer/pathfindingVisualizer.jsx\";\nimport React, { Component } from 'react';\nimport Node from './Node/Node';\nimport { dijkstra, getPath } from '../algorithms/dijkstra';\nimport { astar, getAstarPath } from '../algorithms/astar';\nimport './pathfindingVisualizer.css';\nimport { nodeName } from 'jquery';\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35;\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n\n    this.initGrid = () => {\n      var grid = [];\n      var nodes = {};\n\n      for (let row = 0; row < 20; row++) {\n        const tmpRow = [];\n\n        for (let col = 0; col < 50; col++) {\n          var nodeId = `${row}-${col}`,\n              nodeClass,\n              node;\n          var node = newNode(col, row);\n\n          if (row === START_NODE_ROW && col === START_NODE_COL) {\n            node.status = \"start\";\n          } else if (row === FINISH_NODE_ROW && col === FINISH_NODE_COL) {\n            node.status = \"target\";\n          } else node.status = \"node\";\n\n          tmpRow.push(node);\n          nodes[nodeId] = node;\n        }\n\n        grid.push(tmpRow);\n      }\n\n      return [grid, nodes];\n    };\n\n    this.state = {\n      grid: [],\n      nodes: {},\n      mouseDown: false,\n      algoFinished: true,\n      currentAlgo: null,\n      start: null,\n      target: null\n    };\n  }\n\n  componentDidMount() {\n    const board = this.initGrid();\n    this.setState({\n      grid: board[0],\n      nodes: board[1]\n    });\n  }\n\n  onMouseDown(row, col) {\n    const newGrid = updateGrid(this.state.grid, row, col);\n    const newNodes = updateNodes(this.state.nodes, row, col);\n    this.setState({\n      grid: newGrid,\n      nodes: newNodes,\n      mouseDown: true\n    });\n  }\n\n  onMouseEnter(row, col) {\n    if (!this.state.mouseDown) return;\n    const newGrid = updateGrid(this.state.grid, row, col);\n    const newNodes = updateNodes(this.state.nodes, row, col);\n    this.setState({\n      grid: newGrid,\n      nodes: newNodes\n    });\n  }\n\n  onMouseUp() {\n    this.setState({\n      mouseDown: false\n    });\n  }\n\n  animateSearch(visited, path) {\n    if (visited === false) {\n      console.log(\"No path found.\");\n      this.algoFinished = true;\n      document.getElementById(\"startButton\").disabled = false;\n      document.getElementById(\"clearGridButton\").disabled = false;\n    }\n\n    for (let i = 0; i <= visited.length; i++) {\n      if (i === visited.length) {\n        setTimeout(() => {\n          this.animatePath(path);\n        }, 10 * i);\n        return;\n      } // Visited nodes get animated in 10ms intervals\n\n\n      setTimeout(() => {\n        const node = visited[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n      }, 10 * i);\n    }\n  }\n\n  animatePath(path) {\n    for (let i = 0; i < path.length; i++) {\n      setTimeout(() => {\n        const node = path[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\n      }, 35 * i);\n    }\n\n    this.algoFinished = true;\n    document.getElementById(\"startButton\").disabled = false;\n    document.getElementById(\"clearGridButton\").disabled = false;\n  }\n\n  visualizeSearch() {\n    const algo = document.getElementById(\"startButton\").innerHTML;\n    document.getElementById(\"startButton\").disabled = true;\n    document.getElementById(\"clearGridButton\").disabled = true;\n    console.log(algo);\n    this.algoFinished = false;\n    const {\n      grid,\n      nodes\n    } = this.state;\n    const start = grid[START_NODE_ROW][START_NODE_COL];\n    const goal = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    var visited = [];\n    var path = []; // Select algo based on start button text\n\n    if (algo === \"A* Search\") {\n      console.log(nodes); // console.log(\"start:\", start)\n      // console.log(\"start-id:\", start.id)\n      // console.log(\"goal:\", goal)\n\n      visited = astar(nodes, start, goal, visited, grid, []);\n      path = getAstarPath(goal);\n      console.log(\"Visited:\", visited);\n      console.log(\"Path:\", path);\n      this.animateSearch(visited, path);\n    } else if (algo === \"Dijkstra's Algorithm\") {\n      visited = dijkstra(grid, start, goal);\n      path = getPath(goal);\n      this.animateSearch(visited, path);\n    }\n  }\n\n  clearGrid() {\n    if (this.algoFinished) {\n      const board = this.initGrid();\n      this.setState({\n        grid: board[0],\n        nodes: board[1]\n      });\n\n      for (let row = 0; row < 20; row++) {\n        for (let col = 0; col < 50; col++) {\n          if (row === START_NODE_ROW && col === START_NODE_COL) {\n            //this.nodes[this.start].status = \"start\"\n            document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n          } else if (row === FINISH_NODE_ROW && col === FINISH_NODE_COL) {\n            document.getElementById(`node-${row}-${col}`).className = 'node node-finish'; //this.target.status = \"target\";\n          } else {\n            //this.nodes[`${row}-${col}`].status = \"unvisited\";\n            document.getElementById(`node-${row}-${col}`).className = 'node';\n          }\n        }\n      }\n    }\n  } // Initialize New Grid\n\n\n  render() {\n    const {\n      grid,\n      mouseDown,\n      algoFinished\n    } = this.state;\n    return /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        class: \"center\",\n        children: /*#__PURE__*/_jsxDEV(\"button\", {\n          id: \"startButton\",\n          onClick: () => this.visualizeSearch(),\n          children: \"Visualize Algorithm\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 170,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 169,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        class: \"center\",\n        children: /*#__PURE__*/_jsxDEV(\"button\", {\n          id: \"clearGridButton\",\n          onClick: () => this.clearGrid(),\n          children: \"Clear Grid\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 173,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 172,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"grid\",\n        children: grid.map((row, rowIdx) => {\n          return /*#__PURE__*/_jsxDEV(\"div\", {\n            children: row.map((node, nodeIdx) => {\n              const {\n                row,\n                col,\n                isFinish,\n                isStart,\n                isWall\n              } = node;\n              return /*#__PURE__*/_jsxDEV(Node, {\n                col: col,\n                g: Infinity,\n                h: null,\n                f: Infinity,\n                isFinish: isFinish,\n                isStart: isStart,\n                isWall: isWall,\n                mouseDown: mouseDown,\n                onMouseDown: (row, col) => this.onMouseDown(row, col),\n                onMouseEnter: (row, col) => this.onMouseEnter(row, col),\n                onMouseUp: () => this.onMouseUp(),\n                row: row\n              }, nodeIdx, false, {\n                fileName: _jsxFileName,\n                lineNumber: 182,\n                columnNumber: 21\n              }, this);\n            })\n          }, rowIdx, false, {\n            fileName: _jsxFileName,\n            lineNumber: 178,\n            columnNumber: 15\n          }, this);\n        })\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 175,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true);\n  }\n\n} // Create a new Node\n\nconst newNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    g: Infinity,\n    h: null,\n    f: Infinity,\n    status: null,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n    weight: 0,\n    id: `${row}-${col}`\n  };\n}; // Update our grid state\n\n\nconst updateGrid = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n\n  if (row === START_NODE_ROW && col === START_NODE_COL || row === FINISH_NODE_ROW && col === FINISH_NODE_COL) {\n    return grid;\n  }\n\n  const newNode = { ...node,\n    isWall: !node.isWall\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst updateNodes = (nodes, row, col) => {\n  if (row === START_NODE_ROW && col === START_NODE_COL || row === FINISH_NODE_ROW && col === FINISH_NODE_COL) {\n    return nodes;\n  }\n\n  const newNodes = nodes;\n  const node = nodes[`${row}-${col}`];\n  const newNode = { ...node,\n    isWall: !node.isWall\n  };\n  if (newNode.isWall) newNode.status = \"wall\";\n  newNodes[`${row}-${col}`] = newNode;\n  return newNodes;\n};","map":{"version":3,"sources":["/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/pathfindingVisualizer/pathfindingVisualizer.jsx"],"names":["React","Component","Node","dijkstra","getPath","astar","getAstarPath","nodeName","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","PathfindingVisualizer","constructor","initGrid","grid","nodes","row","tmpRow","col","nodeId","nodeClass","node","newNode","status","push","state","mouseDown","algoFinished","currentAlgo","start","target","componentDidMount","board","setState","onMouseDown","newGrid","updateGrid","newNodes","updateNodes","onMouseEnter","onMouseUp","animateSearch","visited","path","console","log","document","getElementById","disabled","i","length","setTimeout","animatePath","className","visualizeSearch","algo","innerHTML","goal","clearGrid","render","map","rowIdx","nodeIdx","isFinish","isStart","isWall","Infinity","g","h","f","isVisited","previousNode","weight","id","slice"],"mappings":";;;AAAA,OAAOA,KAAP,IAAeC,SAAf,QAA+B,OAA/B;AACA,OAAOC,IAAP,MAAiB,aAAjB;AACA,SAAQC,QAAR,EAAkBC,OAAlB,QAAgC,wBAAhC;AACA,SAAQC,KAAR,EAAeC,YAAf,QAAkC,qBAAlC;AACA,OAAO,6BAAP;AACA,SAASC,QAAT,QAAyB,QAAzB;AAEA,MAAMC,cAAc,GAAG,EAAvB;AACA,MAAMC,cAAc,GAAG,EAAvB;AACA,MAAMC,eAAe,GAAG,EAAxB;AACA,MAAMC,eAAe,GAAG,EAAxB;AAGA,eAAe,MAAMC,qBAAN,SAAoCX,SAApC,CAA8C;AAC3DY,EAAAA,WAAW,GAAG;AACZ;;AADY,SA4HdC,QA5Hc,GA4HH,MAAM;AACf,UAAIC,IAAI,GAAG,EAAX;AACA,UAAIC,KAAK,GAAG,EAAZ;;AACA,WAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAG,EAAxB,EAA4BA,GAAG,EAA/B,EAAmC;AACjC,cAAMC,MAAM,GAAG,EAAf;;AACA,aAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAG,EAAxB,EAA4BA,GAAG,EAA/B,EAAmC;AACjC,cAAIC,MAAM,GAAI,GAAEH,GAAI,IAAGE,GAAI,EAA3B;AAAA,cAA8BE,SAA9B;AAAA,cAAyCC,IAAzC;AACA,cAAIA,IAAI,GAAGC,OAAO,CAACJ,GAAD,EAAMF,GAAN,CAAlB;;AAEA,cAAGA,GAAG,KAAKT,cAAR,IAA0BW,GAAG,KAAKV,cAArC,EAAoD;AAClDa,YAAAA,IAAI,CAACE,MAAL,GAAc,OAAd;AACD,WAFD,MAGK,IAAGP,GAAG,KAAKP,eAAR,IAA2BS,GAAG,KAAKR,eAAtC,EAAsD;AACzDW,YAAAA,IAAI,CAACE,MAAL,GAAc,QAAd;AACD,WAFI,MAGAF,IAAI,CAACE,MAAL,GAAc,MAAd;;AAELN,UAAAA,MAAM,CAACO,IAAP,CAAYH,IAAZ;AACAN,UAAAA,KAAK,CAACI,MAAD,CAAL,GAAgBE,IAAhB;AACD;;AACDP,QAAAA,IAAI,CAACU,IAAL,CAAUP,MAAV;AACD;;AACD,aAAO,CAACH,IAAD,EAAOC,KAAP,CAAP;AACD,KAnJa;;AAEZ,SAAKU,KAAL,GAAa;AACXX,MAAAA,IAAI,EAAE,EADK;AAEXC,MAAAA,KAAK,EAAE,EAFI;AAGXW,MAAAA,SAAS,EAAE,KAHA;AAIXC,MAAAA,YAAY,EAAE,IAJH;AAKXC,MAAAA,WAAW,EAAE,IALF;AAMXC,MAAAA,KAAK,EAAE,IANI;AAOXC,MAAAA,MAAM,EAAE;AAPG,KAAb;AASD;;AAEDC,EAAAA,iBAAiB,GAAG;AAClB,UAAMC,KAAK,GAAG,KAAKnB,QAAL,EAAd;AACA,SAAKoB,QAAL,CAAc;AAACnB,MAAAA,IAAI,EAAEkB,KAAK,CAAC,CAAD,CAAZ;AAAiBjB,MAAAA,KAAK,EAAEiB,KAAK,CAAC,CAAD;AAA7B,KAAd;AACD;;AAEDE,EAAAA,WAAW,CAAClB,GAAD,EAAME,GAAN,EAAW;AACpB,UAAMiB,OAAO,GAAGC,UAAU,CAAC,KAAKX,KAAL,CAAWX,IAAZ,EAAkBE,GAAlB,EAAuBE,GAAvB,CAA1B;AACA,UAAMmB,QAAQ,GAAGC,WAAW,CAAC,KAAKb,KAAL,CAAWV,KAAZ,EAAmBC,GAAnB,EAAwBE,GAAxB,CAA5B;AACA,SAAKe,QAAL,CAAc;AAACnB,MAAAA,IAAI,EAAEqB,OAAP;AAAgBpB,MAAAA,KAAK,EAAEsB,QAAvB;AAAiCX,MAAAA,SAAS,EAAE;AAA5C,KAAd;AACD;;AAEDa,EAAAA,YAAY,CAACvB,GAAD,EAAME,GAAN,EAAW;AACrB,QAAI,CAAC,KAAKO,KAAL,CAAWC,SAAhB,EAA2B;AAC3B,UAAMS,OAAO,GAAGC,UAAU,CAAC,KAAKX,KAAL,CAAWX,IAAZ,EAAkBE,GAAlB,EAAuBE,GAAvB,CAA1B;AACA,UAAMmB,QAAQ,GAAGC,WAAW,CAAC,KAAKb,KAAL,CAAWV,KAAZ,EAAmBC,GAAnB,EAAwBE,GAAxB,CAA5B;AACA,SAAKe,QAAL,CAAc;AAACnB,MAAAA,IAAI,EAAEqB,OAAP;AAAgBpB,MAAAA,KAAK,EAAEsB;AAAvB,KAAd;AACD;;AAEDG,EAAAA,SAAS,GAAG;AACV,SAAKP,QAAL,CAAc;AAACP,MAAAA,SAAS,EAAE;AAAZ,KAAd;AACD;;AAEDe,EAAAA,aAAa,CAACC,OAAD,EAAUC,IAAV,EAAgB;AAC3B,QAAGD,OAAO,KAAK,KAAf,EAAqB;AACnBE,MAAAA,OAAO,CAACC,GAAR,CAAY,gBAAZ;AACA,WAAKlB,YAAL,GAAoB,IAApB;AACAmB,MAAAA,QAAQ,CAACC,cAAT,CAAwB,aAAxB,EAAuCC,QAAvC,GAAkD,KAAlD;AACAF,MAAAA,QAAQ,CAACC,cAAT,CAAwB,iBAAxB,EAA2CC,QAA3C,GAAsD,KAAtD;AACD;;AACD,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIP,OAAO,CAACQ,MAA7B,EAAqCD,CAAC,EAAtC,EAA0C;AACxC,UAAIA,CAAC,KAAKP,OAAO,CAACQ,MAAlB,EAA0B;AACxBC,QAAAA,UAAU,CAAC,MAAM;AACf,eAAKC,WAAL,CAAiBT,IAAjB;AACD,SAFS,EAEP,KAAKM,CAFE,CAAV;AAGA;AACD,OANuC,CAOxC;;;AACAE,MAAAA,UAAU,CAAC,MAAM;AACf,cAAM9B,IAAI,GAAGqB,OAAO,CAACO,CAAD,CAApB;AACAH,QAAAA,QAAQ,CAACC,cAAT,CAAyB,QAAO1B,IAAI,CAACL,GAAI,IAAGK,IAAI,CAACH,GAAI,EAArD,EAAwDmC,SAAxD,GACE,mBADF;AAED,OAJS,EAIP,KAAKJ,CAJE,CAAV;AAKD;AACF;;AAEDG,EAAAA,WAAW,CAACT,IAAD,EAAO;AAChB,SAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,IAAI,CAACO,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;AACpCE,MAAAA,UAAU,CAAC,MAAM;AACf,cAAM9B,IAAI,GAAGsB,IAAI,CAACM,CAAD,CAAjB;AACAH,QAAAA,QAAQ,CAACC,cAAT,CAAyB,QAAO1B,IAAI,CAACL,GAAI,IAAGK,IAAI,CAACH,GAAI,EAArD,EAAwDmC,SAAxD,GACE,yBADF;AAED,OAJS,EAIP,KAAKJ,CAJE,CAAV;AAKD;;AACD,SAAKtB,YAAL,GAAoB,IAApB;AACAmB,IAAAA,QAAQ,CAACC,cAAT,CAAwB,aAAxB,EAAuCC,QAAvC,GAAkD,KAAlD;AACAF,IAAAA,QAAQ,CAACC,cAAT,CAAwB,iBAAxB,EAA2CC,QAA3C,GAAsD,KAAtD;AACD;;AAEDM,EAAAA,eAAe,GAAG;AACd,UAAMC,IAAI,GAAGT,QAAQ,CAACC,cAAT,CAAwB,aAAxB,EAAuCS,SAApD;AACAV,IAAAA,QAAQ,CAACC,cAAT,CAAwB,aAAxB,EAAuCC,QAAvC,GAAkD,IAAlD;AACAF,IAAAA,QAAQ,CAACC,cAAT,CAAwB,iBAAxB,EAA2CC,QAA3C,GAAsD,IAAtD;AACAJ,IAAAA,OAAO,CAACC,GAAR,CAAYU,IAAZ;AACA,SAAK5B,YAAL,GAAoB,KAApB;AACA,UAAM;AAACb,MAAAA,IAAD;AAAOC,MAAAA;AAAP,QAAgB,KAAKU,KAA3B;AACA,UAAMI,KAAK,GAAGf,IAAI,CAACP,cAAD,CAAJ,CAAqBC,cAArB,CAAd;AACA,UAAMiD,IAAI,GAAG3C,IAAI,CAACL,eAAD,CAAJ,CAAsBC,eAAtB,CAAb;AACA,QAAIgC,OAAO,GAAG,EAAd;AACA,QAAIC,IAAI,GAAG,EAAX,CAVc,CAWd;;AACA,QAAGY,IAAI,KAAK,WAAZ,EAAwB;AACtBX,MAAAA,OAAO,CAACC,GAAR,CAAY9B,KAAZ,EADsB,CAEtB;AACA;AACA;;AACA2B,MAAAA,OAAO,GAAGtC,KAAK,CAACW,KAAD,EAAQc,KAAR,EAAe4B,IAAf,EAAqBf,OAArB,EAA8B5B,IAA9B,EAAoC,EAApC,CAAf;AACA6B,MAAAA,IAAI,GAAGtC,YAAY,CAACoD,IAAD,CAAnB;AACAb,MAAAA,OAAO,CAACC,GAAR,CAAY,UAAZ,EAAwBH,OAAxB;AACAE,MAAAA,OAAO,CAACC,GAAR,CAAY,OAAZ,EAAqBF,IAArB;AACA,WAAKF,aAAL,CAAmBC,OAAnB,EAA4BC,IAA5B;AACD,KAVD,MAWK,IAAGY,IAAI,KAAK,sBAAZ,EAAmC;AACtCb,MAAAA,OAAO,GAAGxC,QAAQ,CAACY,IAAD,EAAOe,KAAP,EAAc4B,IAAd,CAAlB;AACAd,MAAAA,IAAI,GAAGxC,OAAO,CAACsD,IAAD,CAAd;AACA,WAAKhB,aAAL,CAAmBC,OAAnB,EAA4BC,IAA5B;AACD;AACJ;;AAEDe,EAAAA,SAAS,GAAG;AACV,QAAG,KAAK/B,YAAR,EAAqB;AACnB,YAAMK,KAAK,GAAG,KAAKnB,QAAL,EAAd;AACA,WAAKoB,QAAL,CAAc;AAACnB,QAAAA,IAAI,EAAEkB,KAAK,CAAC,CAAD,CAAZ;AAAiBjB,QAAAA,KAAK,EAAEiB,KAAK,CAAC,CAAD;AAA7B,OAAd;;AACA,WAAI,IAAIhB,GAAG,GAAG,CAAd,EAAiBA,GAAG,GAAG,EAAvB,EAA2BA,GAAG,EAA9B,EAAkC;AAChC,aAAK,IAAIE,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAG,EAAxB,EAA4BA,GAAG,EAA/B,EAAmC;AACjC,cAAGF,GAAG,KAAKT,cAAR,IAA0BW,GAAG,KAAKV,cAArC,EAAoD;AAClD;AACAsC,YAAAA,QAAQ,CAACC,cAAT,CAAyB,QAAO/B,GAAI,IAAGE,GAAI,EAA3C,EAA8CmC,SAA9C,GAA0D,iBAA1D;AACD,WAHD,MAIK,IAAGrC,GAAG,KAAKP,eAAR,IAA2BS,GAAG,KAAKR,eAAtC,EAAsD;AACzDoC,YAAAA,QAAQ,CAACC,cAAT,CAAyB,QAAO/B,GAAI,IAAGE,GAAI,EAA3C,EAA8CmC,SAA9C,GAA0D,kBAA1D,CADyD,CAEzD;AACD,WAHI,MAID;AACF;AACAP,YAAAA,QAAQ,CAACC,cAAT,CAAyB,QAAO/B,GAAI,IAAGE,GAAI,EAA3C,EAA8CmC,SAA9C,GAA0D,MAA1D;AACD;AACF;AACF;AACF;AACF,GA3H0D,CA4H3D;;;AA0BAM,EAAAA,MAAM,GAAG;AACP,UAAM;AAAC7C,MAAAA,IAAD;AAAOY,MAAAA,SAAP;AAAkBC,MAAAA;AAAlB,QAAkC,KAAKF,KAA7C;AAEA,wBACE;AAAA,8BACE;AAAK,QAAA,KAAK,EAAC,QAAX;AAAA,+BACE;AAAQ,UAAA,EAAE,EAAC,aAAX;AAAyB,UAAA,OAAO,EAAE,MAAM,KAAK6B,eAAL,EAAxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADF;AAAA;AAAA;AAAA;AAAA,cADF,eAIE;AAAK,QAAA,KAAK,EAAC,QAAX;AAAA,+BACE;AAAQ,UAAA,EAAE,EAAC,iBAAX;AAA6B,UAAA,OAAO,EAAE,MAAM,KAAKI,SAAL,EAA5C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADF;AAAA;AAAA;AAAA;AAAA,cAJF,eAOE;AAAK,QAAA,SAAS,EAAC,MAAf;AAAA,kBACG5C,IAAI,CAAC8C,GAAL,CAAS,CAAC5C,GAAD,EAAM6C,MAAN,KAAiB;AACzB,8BACE;AAAA,sBACG7C,GAAG,CAAC4C,GAAJ,CAAQ,CAACvC,IAAD,EAAOyC,OAAP,KAAmB;AAC1B,oBAAM;AAAC9C,gBAAAA,GAAD;AAAME,gBAAAA,GAAN;AAAW6C,gBAAAA,QAAX;AAAqBC,gBAAAA,OAArB;AAA8BC,gBAAAA;AAA9B,kBAAwC5C,IAA9C;AACA,kCACE,QAAC,IAAD;AAEE,gBAAA,GAAG,EAAEH,GAFP;AAGE,gBAAA,CAAC,EAAIgD,QAHP;AAIE,gBAAA,CAAC,EAAI,IAJP;AAKE,gBAAA,CAAC,EAAIA,QALP;AAME,gBAAA,QAAQ,EAAEH,QANZ;AAOE,gBAAA,OAAO,EAAEC,OAPX;AAQE,gBAAA,MAAM,EAAEC,MARV;AASE,gBAAA,SAAS,EAAEvC,SATb;AAUE,gBAAA,WAAW,EAAE,CAACV,GAAD,EAAME,GAAN,KAAc,KAAKgB,WAAL,CAAiBlB,GAAjB,EAAsBE,GAAtB,CAV7B;AAWE,gBAAA,YAAY,EAAE,CAACF,GAAD,EAAME,GAAN,KAAc,KAAKqB,YAAL,CAAkBvB,GAAlB,EAAuBE,GAAvB,CAX9B;AAYE,gBAAA,SAAS,EAAE,MAAM,KAAKsB,SAAL,EAZnB;AAaE,gBAAA,GAAG,EAAExB;AAbP,iBACO8C,OADP;AAAA;AAAA;AAAA;AAAA,sBADF;AAgBD,aAlBA;AADH,aAAUD,MAAV;AAAA;AAAA;AAAA;AAAA,kBADF;AAuBD,SAxBA;AADH;AAAA;AAAA;AAAA;AAAA,cAPF;AAAA,oBADF;AAqCD;;AA9L0D,C,CAiM7D;;AACA,MAAMvC,OAAO,GAAG,CAACJ,GAAD,EAAMF,GAAN,KAAc;AAC5B,SAAO;AACLE,IAAAA,GADK;AAELF,IAAAA,GAFK;AAGLgD,IAAAA,OAAO,EAAEhD,GAAG,KAAKT,cAAR,IAA0BW,GAAG,KAAKV,cAHtC;AAILuD,IAAAA,QAAQ,EAAE/C,GAAG,KAAKP,eAAR,IAA2BS,GAAG,KAAKR,eAJxC;AAKLyD,IAAAA,CAAC,EAAED,QALE;AAMLE,IAAAA,CAAC,EAAE,IANE;AAOLC,IAAAA,CAAC,EAAEH,QAPE;AAQL3C,IAAAA,MAAM,EAAE,IARH;AASL+C,IAAAA,SAAS,EAAE,KATN;AAULL,IAAAA,MAAM,EAAE,KAVH;AAWLM,IAAAA,YAAY,EAAE,IAXT;AAYLC,IAAAA,MAAM,EAAE,CAZH;AAaLC,IAAAA,EAAE,EAAG,GAAEzD,GAAI,IAAGE,GAAI;AAbb,GAAP;AAeD,CAhBD,C,CAkBA;;;AACA,MAAMkB,UAAU,GAAG,CAACtB,IAAD,EAAOE,GAAP,EAAYE,GAAZ,KAAoB;AACrC,QAAMiB,OAAO,GAAGrB,IAAI,CAAC4D,KAAL,EAAhB;AACA,QAAMrD,IAAI,GAAGc,OAAO,CAACnB,GAAD,CAAP,CAAaE,GAAb,CAAb;;AACA,MAAGF,GAAG,KAAKT,cAAR,IAA0BW,GAAG,KAAKV,cAAlC,IACEQ,GAAG,KAAKP,eAAR,IAA2BS,GAAG,KAAKR,eADxC,EACwD;AACtD,WAAOI,IAAP;AACD;;AACD,QAAMQ,OAAO,GAAG,EACd,GAAGD,IADW;AAEf4C,IAAAA,MAAM,EAAE,CAAC5C,IAAI,CAAC4C;AAFC,GAAhB;AAIA9B,EAAAA,OAAO,CAACnB,GAAD,CAAP,CAAaE,GAAb,IAAoBI,OAApB;AACA,SAAOa,OAAP;AACD,CAbD;;AAeA,MAAMG,WAAW,GAAG,CAACvB,KAAD,EAAQC,GAAR,EAAaE,GAAb,KAAqB;AACvC,MAAGF,GAAG,KAAKT,cAAR,IAA0BW,GAAG,KAAKV,cAAlC,IACEQ,GAAG,KAAKP,eAAR,IAA2BS,GAAG,KAAKR,eADxC,EACwD;AACtD,WAAOK,KAAP;AACD;;AACD,QAAMsB,QAAQ,GAAGtB,KAAjB;AACA,QAAMM,IAAI,GAAGN,KAAK,CAAE,GAAEC,GAAI,IAAGE,GAAI,EAAf,CAAlB;AACA,QAAMI,OAAO,GAAG,EACd,GAAGD,IADW;AAEd4C,IAAAA,MAAM,EAAE,CAAC5C,IAAI,CAAC4C;AAFA,GAAhB;AAIA,MAAG3C,OAAO,CAAC2C,MAAX,EAAmB3C,OAAO,CAACC,MAAR,GAAiB,MAAjB;AACnBc,EAAAA,QAAQ,CAAE,GAAErB,GAAI,IAAGE,GAAI,EAAf,CAAR,GAA4BI,OAA5B;AACA,SAAOe,QAAP;AACD,CAdD","sourcesContent":["import React, {Component} from 'react';\nimport Node from './Node/Node';\nimport {dijkstra, getPath} from '../algorithms/dijkstra';\nimport {astar, getAstarPath} from '../algorithms/astar';\nimport './pathfindingVisualizer.css';\nimport { nodeName } from 'jquery';\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35;\n\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      nodes: {},\n      mouseDown: false,\n      algoFinished: true,\n      currentAlgo: null,\n      start: null,\n      target: null\n    };\n  }\n\n  componentDidMount() {\n    const board = this.initGrid();\n    this.setState({grid: board[0], nodes: board[1]});\n  }\n\n  onMouseDown(row, col) {\n    const newGrid = updateGrid(this.state.grid, row, col);\n    const newNodes = updateNodes(this.state.nodes, row, col);\n    this.setState({grid: newGrid, nodes: newNodes, mouseDown: true});\n  }\n\n  onMouseEnter(row, col) {\n    if (!this.state.mouseDown) return;\n    const newGrid = updateGrid(this.state.grid, row, col);\n    const newNodes = updateNodes(this.state.nodes, row, col);\n    this.setState({grid: newGrid, nodes: newNodes});\n  }\n\n  onMouseUp() {\n    this.setState({mouseDown: false});\n  }\n\n  animateSearch(visited, path) {\n    if(visited === false){\n      console.log(\"No path found.\")\n      this.algoFinished = true;\n      document.getElementById(\"startButton\").disabled = false;\n      document.getElementById(\"clearGridButton\").disabled = false;\n    }\n    for (let i = 0; i <= visited.length; i++) {\n      if (i === visited.length) {\n        setTimeout(() => {\n          this.animatePath(path);\n        }, 10 * i);\n        return;\n      }\n      // Visited nodes get animated in 10ms intervals\n      setTimeout(() => {\n        const node = visited[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-visited';\n      }, 10 * i);\n    }\n  }\n\n  animatePath(path) {\n    for (let i = 0; i < path.length; i++) {\n      setTimeout(() => {\n        const node = path[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-shortest-path';\n      }, 35 * i);\n    }\n    this.algoFinished = true;\n    document.getElementById(\"startButton\").disabled = false;\n    document.getElementById(\"clearGridButton\").disabled = false;\n  }\n\n  visualizeSearch() {\n      const algo = document.getElementById(\"startButton\").innerHTML;\n      document.getElementById(\"startButton\").disabled = true;\n      document.getElementById(\"clearGridButton\").disabled = true;\n      console.log(algo);\n      this.algoFinished = false;\n      const {grid, nodes} = this.state;\n      const start = grid[START_NODE_ROW][START_NODE_COL];\n      const goal = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n      var visited = [];\n      var path = [];\n      // Select algo based on start button text\n      if(algo === \"A* Search\"){\n        console.log(nodes)\n        // console.log(\"start:\", start)\n        // console.log(\"start-id:\", start.id)\n        // console.log(\"goal:\", goal)\n        visited = astar(nodes, start, goal, visited, grid, []);\n        path = getAstarPath(goal);\n        console.log(\"Visited:\", visited);\n        console.log(\"Path:\", path);\n        this.animateSearch(visited, path);\n      }\n      else if(algo === \"Dijkstra's Algorithm\"){\n        visited = dijkstra(grid, start, goal);\n        path = getPath(goal);\n        this.animateSearch(visited, path);\n      }\n  }\n\n  clearGrid() {\n    if(this.algoFinished){\n      const board = this.initGrid();\n      this.setState({grid: board[0], nodes: board[1]});\n      for(let row = 0; row < 20; row++) {\n        for (let col = 0; col < 50; col++) {\n          if(row === START_NODE_ROW && col === START_NODE_COL){\n            //this.nodes[this.start].status = \"start\"\n            document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n          }\n          else if(row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\n            document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n            //this.target.status = \"target\";\n          }\n          else{\n            //this.nodes[`${row}-${col}`].status = \"unvisited\";\n            document.getElementById(`node-${row}-${col}`).className = 'node';\n          }\n        }\n      }\n    }\n  }\n  // Initialize New Grid\n  initGrid = () => {\n    var grid = [];\n    var nodes = {};\n    for (let row = 0; row < 20; row++) {\n      const tmpRow = [];\n      for (let col = 0; col < 50; col++) {\n        var nodeId = `${row}-${col}`, nodeClass, node;\n        var node = newNode(col, row);\n\n        if(row === START_NODE_ROW && col === START_NODE_COL){\n          node.status = \"start\"\n        } \n        else if(row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\n          node.status = \"target\"\n        } \n        else node.status = \"node\"\n\n        tmpRow.push(node);\n        nodes[nodeId] = node;\n      }\n      grid.push(tmpRow);\n    }\n    return [grid, nodes];\n  };\n\n  render() {\n    const {grid, mouseDown, algoFinished} = this.state;\n    \n    return (\n      <>\n        <div class=\"center\">\n          <button id=\"startButton\" onClick={() => this.visualizeSearch()}>Visualize Algorithm</button>\n        </div>\n        <div class=\"center\">\n          <button id=\"clearGridButton\" onClick={() => this.clearGrid()}>Clear Grid</button>\n        </div>\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const {row, col, isFinish, isStart, isWall} = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      g = {Infinity}\n                      h = {null}\n                      f = {Infinity}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      mouseDown={mouseDown}\n                      onMouseDown={(row, col) => this.onMouseDown(row, col)}\n                      onMouseEnter={(row, col) => this.onMouseEnter(row, col)}\n                      onMouseUp={() => this.onMouseUp()}\n                      row={row}></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </>\n    );\n  }\n}\n\n// Create a new Node\nconst newNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    g: Infinity,\n    h: null,\n    f: Infinity,\n    status: null,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n    weight: 0,\n    id: `${row}-${col}`\n  };\n};\n\n// Update our grid state\nconst updateGrid = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  if(row === START_NODE_ROW && col === START_NODE_COL \n    || row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\n    return grid;\n  }\n  const newNode = {\n    ...node,\n   isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst updateNodes = (nodes, row, col) => {\n  if(row === START_NODE_ROW && col === START_NODE_COL \n    || row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\n    return nodes;\n  }\n  const newNodes = nodes;\n  const node = nodes[`${row}-${col}`];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  if(newNode.isWall) newNode.status = \"wall\";\n  newNodes[`${row}-${col}`] = newNode;\n  return newNodes;\n}"]},"metadata":{},"sourceType":"module"}