[{"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/index.js":"1","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/App.js":"2","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/navbar.jsx":"3","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/pathfindingVisualizer/pathfindingVisualizer.jsx":"4","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/astar.js":"5","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/dijkstra.js":"6","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/pathfindingVisualizer/Node/Node.jsx":"7","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/bfs.js":"8","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/dfs.js":"9"},{"size":167,"mtime":1609794319429,"results":"10","hashOfConfig":"11"},{"size":315,"mtime":1609990304703,"results":"12","hashOfConfig":"11"},{"size":1810,"mtime":1609989992895,"results":"13","hashOfConfig":"11"},{"size":26401,"mtime":1609994412312,"results":"14","hashOfConfig":"11"},{"size":8726,"mtime":1609991582573,"results":"15","hashOfConfig":"11"},{"size":2076,"mtime":1609830298898,"results":"16","hashOfConfig":"11"},{"size":686,"mtime":1609993023384,"results":"17","hashOfConfig":"11"},{"size":1398,"mtime":1609966021968,"results":"18","hashOfConfig":"11"},{"size":1396,"mtime":1609966341759,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"1entc3h",{"filePath":"23","messages":"24","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25","usedDeprecatedRules":"22"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"28","usedDeprecatedRules":"22"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"31","messages":"32","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33","usedDeprecatedRules":"22"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/index.js",[],["42","43"],"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/App.js",["44"],"import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './pathfindingVisualizer/pathfindingVisualizer';\nimport Navbar from './navbar';\n\nfunction App() {\n  return (    \n    <div className=\"App\">\n\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div> \n  );\n}\n\nexport default App;\n","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/navbar.jsx",["45","46","47","48"],"import React, {Component} from 'react';\nimport './navbar.css';\n\nexport default class Navbar extends Component{\n\n    constructor(props){\n        super(props);\n        this.state = {value: props.value};\n    }\n\n    handleChange(event){\n        this.setState({value: event.target.value});\n    }\n    \n    toggleDropdown(){\n        document.getElementById(\"myDropdown\").classList.toggle(\"show\");\n    }\n\n    selectAlgo(algoName){\n        this.toggleDropdown();\n        document.getElementById(\"startButton\").innerHTML = algoName;\n    }\n\n    render(){\n        return(\n            <div class=\"navbar\">\n                <div class=\"dropdown\">\n                    <button onClick={() => this.toggleDropdown()} class=\"dropbtn\">Select an Algorithm</button>\n                    <div id=\"myDropdown\" class=\"dropdown-content\">\n                        <a href=\"#\" id=\"dijkstraStart\" onClick={() => this.selectAlgo(\"Dijkstra's Algorithm\")}>Dijkstra's Algorithm</a>\n                        <a href=\"#\" id=\"astarStart\" onClick={() => this.selectAlgo(\"A* Search\")}>A* Search</a>\n                        <a href=\"#\" id=\"bfsStart\" onClick={() => this.selectAlgo(\"Breadth-First-Search\")}>BFS</a>\n                        <a href=\"#\" id=\"dfsStart\" onClick={() => this.selectAlgo(\"Depth-First-Search\")}>DFS</a>\n                    </div>\n                </div>\n            </div>\n        )\n    }\n\n}    \n// Close the dropdown menu if the user clicks outside of it\nwindow.onclick = function(event) {\n    if (!event.target.matches('.dropbtn')) {\n    var dropdowns = document.getElementsByClassName(\"dropdown-content\");\n    var i;\n    for (i = 0; i < dropdowns.length; i++) {\n        var openDropdown = dropdowns[i];\n        if (openDropdown.classList.contains('show')) {\n        openDropdown.classList.remove('show');\n        }\n    }\n    }\n}","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/pathfindingVisualizer/pathfindingVisualizer.jsx",["49","50","51","52"],"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/astar.js",["53"],"// A* Search Algorithm\n//  - Allowable Moves: [N, E, S, W]\n//  - Inputs\n//      - Adjacency Matrix\n//      - Start Node\n//      - Goal Node\n//  - Output:\n//      - Guarenteed shortest possible path\n// export function astar(nodes, start, goal, explored, grid, heuristic){\n//     if(!start || !goal || start === goal)\n//         return false;\n//     nodes[start.id].g = 0;\n//     nodes[start.id].f = 0;\n//     nodes[start.id].direction = \"N\";\n//     let frontier = Object.keys(nodes);\n//     console.log(\"frontier:\", frontier)\n//     while(frontier.length){\n//         // Pop the next closest node off the frontier\n//         let node = closestNode(nodes, frontier);\n//         // Make sure the node is not a wall\n//         while(node.status === \"wall\"  && frontier.length){\n//             node = closestNode(nodes, frontier);\n//         }\n//         if(node.g === Infinity) return false;\n//         explored.push(node);\n//         node.status = \"visited\";\n//         if(node.id === goal.id) return explored;\n\n//         updateNeighbors(nodes, node, grid, start, goal, heuristic);\n\n//     }\n    \n// }\n\n// function closestNode(nodes, frontier){\n//     let node, index;\n//     for(let i = 0; i < frontier.length; i++){\n//         if(!node || node.f > nodes[frontier[i]].f){\n//             node = nodes[frontier[i]];\n//             index = i;\n//         }\n//         else if(node.f === nodes[frontier[i]].f){\n//             if(node.h > nodes[frontier[i]].h){\n//                 node = nodes[frontier[i]];\n//                 index = i;\n//             }\n//         }\n//     }\n//     frontier.splice(index, 1);\n//     return node;\n// }\n\n// function updateNeighbors(nodes, node, grid, start, target, heuristic){\n//     let neighbors = getNeighbors(node.id, nodes, grid);\n//     for(let neighbor of neighbors){\n//         if(target){\n//             // console.log(\"node:\", node);\n//             // console.log(\"neighbor:\", neighbor)\n//             updateNode(node, nodes[neighbor], nodes[start.id], nodes[target.id], nodes, grid, heuristic);\n//         }\n//         else{\n//             updateNode(node, nodes[neighbor]);\n//         }\n//     }\n// }\n\n// function updateNode(node, tmpTarget, trueStart, trueTarget, nodes, grid, heuristic){\n//     let path = getPathCost(node, tmpTarget);\n//     // If our new target node has no heuristic => Assign to be manhattan distance\n//     if(!tmpTarget.h) tmpTarget.h = manhattanDistance(tmpTarget, trueTarget);\n//     let dist = node.g + tmpTarget.weight + path[0];\n//     if(dist < tmpTarget.g){\n//         tmpTarget.g = dist;\n//         tmpTarget.f = tmpTarget.g + tmpTarget.h\n//         tmpTarget.previousNode = node;\n//         tmpTarget.path = path[1];\n//         tmpTarget.direction = path[2];\n//     }\n// }\n\n// function getNeighbors(id, nodes, grid){\n//     let coords = id.split(\"-\");\n//     let x = parseInt(coords[0]);\n//     let y = parseInt(coords[1]);\n//     let neighbors = [];\n//     let neighbor;\n//     // North\n//     if(grid[x-1] && grid[x-1][y]){\n//         neighbor = `${(x-1).toString()}-${y.toString()}`;\n//         if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n//     }\n//     // South\n//     if(grid[x+1] && grid[x+1][y]){\n//         neighbor = `${(x+1).toString()}-${y.toString()}`;\n//         if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n//     }\n//     if(grid[x][y-1]){\n//         neighbor = `${x.toString()}-${(y - 1).toString()}`;\n//         if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n//     }\n//     if(grid[x][y+1]){\n//         neighbor = `${x.toString()}-${(y + 1).toString()}`;\n//         if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n//     }\n//     return neighbors;\n// }\n\n// function getPathCost(nodeA, nodeB){\n//     let startCoords = nodeA.id.split(\"-\");\n//     let targetCoords = nodeB.id.split(\"-\");\n//     let nodeAx = parseInt(startCoords[0]);\n//     let nodeAy = parseInt(startCoords[1]);\n//     let nodeBx = parseInt(targetCoords[0]);\n//     let nodeBy = parseInt(targetCoords[1]);\n//     // B is above A\n//     if(nodeBx < nodeAx && nodeAy === nodeBy){\n//         if(nodeA.direction === \"N\") return [1, [\"f\"], \"N\"];\n//         else if(nodeA.direction === \"E\") return [2, [\"l\", \"f\"], \"N\"];\n//         else if(nodeA.direction === \"W\") return [2, [\"r\", \"f\"], \"N\"];\n//         else if(nodeA.direction === \"S\") return [3, [\"r\", \"r\", \"f\"], \"N\"];\n//         else if(nodeA.direction === \"NE\") return [1.5, null, \"N\"];\n//         else if(nodeA.direction === \"SE\") return [2.5, null, \"N\"];\n//         else if(nodeA.direction === \"NW\") return [1.5, null, \"N\"];\n//         else if(nodeA.direction === \"SW\") return [2.5, null, \"N\"];\n//     }\n//     else if(nodeBx > nodeAx && nodeAy === nodeBy){\n//         if(nodeA.direction === \"N\") return [3, [\"r\", \"r\", \"f\"], \"S\"];\n//         else if(nodeA.direction === \"E\") return [2, [\"r\", \"f\"], \"S\"];\n//         else if(nodeA.direction === \"W\") return [2, [\"l\", \"f\"], \"S\"];\n//         else if(nodeA.direction === \"S\") return [1, [\"f\"], \"S\"];\n//         else if(nodeA.direction === \"NE\") return [2.5, null, \"S\"];\n//         else if(nodeA.direction === \"SE\") return [1.5, null, \"S\"];\n//         else if(nodeA.direction === \"NW\") return [2.5, null, \"S\"];\n//         else if(nodeA.direction === \"SW\") return [1.5, null, \"S\"];\n//     }\n//     if(nodeBy < nodeAy && nodeAx === nodeBx){\n//         if(nodeA.direction === \"N\") return [2, [\"l\", \"f\"], \"W\"];\n//         else if(nodeA.direction === \"E\") return [3, [\"l\", \"l\", \"f\"], \"W\"];\n//         else if(nodeA.direction === \"W\") return [1, [\"f\"], \"W\"];\n//         else if(nodeA.direction === \"S\") return [2, [\"r\", \"f\"], \"W\"];\n//         else if(nodeA.direction === \"NE\") return [2.5, null, \"W\"];\n//         else if(nodeA.direction === \"SE\") return [2.5, null, \"W\"];\n//         else if(nodeA.direction === \"NW\") return [1.5, null, \"W\"];\n//         else if(nodeA.direction === \"SW\") return [1.5, null, \"W\"];\n//     }\n//     else if(nodeBy > nodeAy && nodeAx === nodeBx){\n//         if(nodeA.direction === \"N\") return [2, [\"r\", \"f\"], \"E\"];\n//         else if(nodeA.direction === \"E\") return [1, [\"f\"], \"E\"];\n//         else if(nodeA.direction === \"W\") return [3, [\"r\",\"r\",\"f\"], \"E\"];\n//         else if(nodeA.direction === \"S\") return [2, [\"l\", \"f\"], \"E\"];\n//         else if(nodeA.direction === \"NE\") return [1.5, null, \"E\"];\n//         else if(nodeA.direction === \"SE\") return [1.5, null, \"E\"];\n//         else if(nodeA.direction === \"NW\") return [2.5, null, \"E\"];\n//         else if(nodeA.direction === \"SW\") return [2.5, null, \"E\"];\n//     }\n// }\n\n// function manhattanDistance(nodeA, nodeB){\n//     let nodeAcoords = nodeA.id.split(\"-\").map(x => parseInt(x));\n//     let nodeBcoords = nodeB.id.split(\"-\").map(x => parseInt(x));\n//     let nodeAx = nodeAcoords[0];\n//     let nodeBx = nodeBcoords[0];\n//     let nodeAy = nodeAcoords[1];\n//     let nodeBy = nodeBcoords[1];\n\n//     let delta_x = Math.abs(nodeAx - nodeBx);\n//     let delta_y = Math.abs(nodeAy - nodeBy);\n\n//     return (delta_x + delta_y);\n// }\n\nexport function astar(grid, start, goal){\n\n    const visited = [];\n    start.distance = 0;\n    const frontier = getNodes(grid);\n\n    while(frontier.length){\n        sortByDistance(frontier);\n        const node = frontier.shift();\n        if(!node.isWall){\n            if(node.distance === Infinity) return false;\n            node.isVisited = true;\n            visited.push(node);\n            if(node == goal) return visited;\n            updateUnvisitedNeighbors(node, grid);\n        }\n    }\n}\n\nfunction getNodes(grid){\n    const nodes = [];\n    for(const row of grid){\n        for(const node of row){\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\nfunction sortByDistance(unvisitedNodes) {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n      neighbor.distance = node.distance + 1 + neighbor.distanceToFinishNode;\n      neighbor.previousNode = node;\n    }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nexport function getAstarPath(goal) {\n    const path = [];\n    let tmpNode = goal;\n    while (tmpNode !== null) {\n      path.unshift(tmpNode);\n      tmpNode = tmpNode.previousNode;\n    }\n    return path;\n  }\n\n","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/dijkstra.js",[],"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/pathfindingVisualizer/Node/Node.jsx",[],"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/bfs.js",[],"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/dfs.js",[],{"ruleId":"54","replacedBy":"55"},{"ruleId":"56","replacedBy":"57"},{"ruleId":"58","severity":1,"message":"59","line":4,"column":8,"nodeType":"60","messageId":"61","endLine":4,"endColumn":14},{"ruleId":"62","severity":1,"message":"63","line":30,"column":25,"nodeType":"64","endLine":30,"endColumn":112},{"ruleId":"62","severity":1,"message":"63","line":31,"column":25,"nodeType":"64","endLine":31,"endColumn":98},{"ruleId":"62","severity":1,"message":"63","line":32,"column":25,"nodeType":"64","endLine":32,"endColumn":107},{"ruleId":"62","severity":1,"message":"63","line":33,"column":25,"nodeType":"64","endLine":33,"endColumn":105},{"ruleId":"58","severity":1,"message":"65","line":9,"column":7,"nodeType":"60","messageId":"61","endLine":9,"endColumn":21},{"ruleId":"58","severity":1,"message":"66","line":10,"column":7,"nodeType":"60","messageId":"61","endLine":10,"endColumn":21},{"ruleId":"58","severity":1,"message":"67","line":11,"column":7,"nodeType":"60","messageId":"61","endLine":11,"endColumn":22},{"ruleId":"58","severity":1,"message":"68","line":12,"column":7,"nodeType":"60","messageId":"61","endLine":12,"endColumn":22},{"ruleId":"69","severity":1,"message":"70","line":185,"column":21,"nodeType":"71","messageId":"72","endLine":185,"endColumn":23},"no-native-reassign",["73"],"no-negated-in-lhs",["74"],"no-unused-vars","'Navbar' is defined but never used.","Identifier","unusedVar","jsx-a11y/anchor-is-valid","The href attribute requires a valid value to be accessible. Provide a valid, navigable address as the href value. If you cannot provide a valid href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement","'START_NODE_ROW' is assigned a value but never used.","'START_NODE_COL' is assigned a value but never used.","'FINISH_NODE_ROW' is assigned a value but never used.","'FINISH_NODE_COL' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-global-assign","no-unsafe-negation"]