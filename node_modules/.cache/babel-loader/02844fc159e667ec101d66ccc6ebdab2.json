{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";// Dijkstra's Algorithm:\n//  - Inputs:\n//      - 2D Grid Matrix\n//      - Start Node\n//      - Goal Node\n//  - Output:\n//      - List of nodes representing the shortest possible path, if one exists.\nexport function dijkstra(grid,start,goal){var visited=[];start.g=0;var frontier=getNodes(grid);while(!!frontier.length){sortNodes(frontier);// Guarenteed to be next closest node since we've just sorted the unvisited nodes by distance\nvar node=frontier.shift();// Skip checks for any walls\nif(node.isWall)continue;// If the closest node is infinite distance, then no path exists to our goal\nif(node.g===Infinity)return visited;node.isVisited=true;visited.push(node);if(node===goal)return visited;updateNeighborCosts(node,grid);}}// Sort the nodes by distance\nfunction sortNodes(frontier){frontier.sort(function(nodeA,nodeB){return nodeA.g-nodeB.g;});}function updateNeighborCosts(node,grid){var unvisitedNeighbors=getNeighbors(node,grid);var _iterator=_createForOfIteratorHelper(unvisitedNeighbors),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var neighbor=_step.value;neighbor.g=node.g+1;neighbor.previousNode=node;}}catch(err){_iterator.e(err);}finally{_iterator.f();}}function getNeighbors(node,grid){var neighbors=[];var col=node.col,row=node.row;if(row>0)neighbors.push(grid[row-1][col]);if(row<grid.length-1)neighbors.push(grid[row+1][col]);if(col>0)neighbors.push(grid[row][col-1]);if(col<grid[0].length-1)neighbors.push(grid[row][col+1]);return neighbors.filter(function(neighbor){return!neighbor.isVisited;});}function getNodes(grid){var nodes=[];var _iterator2=_createForOfIteratorHelper(grid),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var row=_step2.value;var _iterator3=_createForOfIteratorHelper(row),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var node=_step3.value;nodes.push(node);}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}return nodes;}// Backtracks from the goal to find the shortest path.\nexport function getPath(goal){var path=[];var tmpNode=goal;while(tmpNode!==null){path.unshift(tmpNode);tmpNode=tmpNode.previousNode;}return path;}","map":{"version":3,"sources":["/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/dijkstra.js"],"names":["dijkstra","grid","start","goal","visited","g","frontier","getNodes","length","sortNodes","node","shift","isWall","Infinity","isVisited","push","updateNeighborCosts","sort","nodeA","nodeB","unvisitedNeighbors","getNeighbors","neighbor","previousNode","neighbors","col","row","filter","nodes","getPath","path","tmpNode","unshift"],"mappings":"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","sourcesContent":["// Dijkstra's Algorithm:\n//  - Inputs:\n//      - 2D Grid Matrix\n//      - Start Node\n//      - Goal Node\n//  - Output:\n//      - List of nodes representing the shortest possible path, if one exists.\n\nexport function dijkstra(grid, start, goal) {\n    const visited = [];\n    start.g = 0;\n    const frontier = getNodes(grid);\n    while (!!frontier.length) {\n      sortNodes(frontier);\n      // Guarenteed to be next closest node since we've just sorted the unvisited nodes by distance\n      const node = frontier.shift();\n      \n      // Skip checks for any walls\n      if (node.isWall) continue;\n      // If the closest node is infinite distance, then no path exists to our goal\n      if (node.g === Infinity) return visited;\n\n      node.isVisited = true;\n      visited.push(node);\n      if (node === goal) return visited;\n      updateNeighborCosts(node, grid);\n    }\n  }\n  \n  // Sort the nodes by distance\n  function sortNodes(frontier) {\n    frontier.sort((nodeA, nodeB) => nodeA.g - nodeB.g);\n  }\n  \n  function updateNeighborCosts(node, grid) {\n    const unvisitedNeighbors = getNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n      neighbor.g = node.g + 1;\n      neighbor.previousNode = node;\n    }\n  }\n  \n  function getNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n  }\n  \n  function getNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        nodes.push(node);\n      }\n    }\n    return nodes;\n  }\n  \n  // Backtracks from the goal to find the shortest path.\n\n  export function getPath(goal) {\n    const path = [];\n    let tmpNode = goal;\n    while (tmpNode !== null) {\n      path.unshift(tmpNode);\n      tmpNode = tmpNode.previousNode;\n    }\n    return path;\n  }"]},"metadata":{},"sourceType":"module"}