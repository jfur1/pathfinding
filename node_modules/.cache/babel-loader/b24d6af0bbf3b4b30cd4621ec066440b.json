{"ast":null,"code":"// A* Search Algorithm\n//  - Allowable Moves: [N, E, S, W]\n//  - Inputs\n//      - Adjacency Matrix\n//      - Start Node\n//      - Goal Node\n//  - Output:\n//      - Guarenteed shortest possible path\nexport function astar(nodes, start, goal, explored, grid, heuristic) {\n  if (!start || !goal || start === goal) return false;\n  nodes[start.id].g = 0;\n  nodes[start.id].f = 0;\n  nodes[start.id].direction = \"N\";\n  let frontier = Object.keys(nodes);\n  console.log(\"frontier:\", frontier);\n\n  while (frontier.length) {\n    // Pop the next closest node off the frontier\n    let node = closestNode(nodes, frontier); // Make sure the node is not a wall\n\n    while (node.status === \"wall\" && frontier.length) {\n      node = closestNode(nodes, frontier);\n    }\n\n    if (node.g === Infinity) return false;\n    explored.push(node);\n    node.status = \"visited\";\n    if (node.id === goal.id) return explored;\n    updateNeighbors(nodes, node, grid, start, goal, heuristic);\n  }\n}\n\nfunction closestNode(nodes, frontier) {\n  let node, index;\n\n  for (let i = 0; i < frontier.length; i++) {\n    if (!node || node.f > nodes[frontier[i]].f) {\n      node = nodes[frontier[i]];\n      index = i;\n    } else if (node.f === nodes[frontier[i]].f) {\n      if (node.h > nodes[frontier[i]].h) {\n        node = nodes[frontier[i]];\n        index = i;\n      }\n    }\n  }\n\n  frontier.splice(index, 1);\n  return node;\n}\n\nfunction updateNeighbors(nodes, node, grid, start, target, heuristic) {\n  let neighbors = getNeighbors(node.id, nodes, grid);\n\n  for (let neighbor of neighbors) {\n    if (target) {\n      // console.log(\"node:\", node);\n      // console.log(\"neighbor:\", neighbor)\n      updateNode(node, nodes[neighbor], nodes[start.id], nodes[target.id], nodes, grid, heuristic);\n    } else {\n      updateNode(node, nodes[neighbor]);\n    }\n  }\n}\n\nfunction updateNode(node, tmpTarget, trueStart, trueTarget, nodes, grid, heuristic) {\n  let path = getPathCost(node, tmpTarget); // If our new target node has no heuristic => Assign to be manhattan distance\n\n  if (!tmpTarget.h) tmpTarget.h = manhattanDistance(tmpTarget, trueTarget);\n  let dist = node.g + tmpTarget.weight + path[0];\n\n  if (dist < tmpTarget.g) {\n    tmpTarget.g = dist;\n    tmpTarget.f = tmpTarget.g + tmpTarget.h;\n    tmpTarget.previousNode = node;\n    tmpTarget.path = path[1];\n    tmpTarget.direction = path[2];\n  }\n}\n\nfunction getNeighbors(id, nodes, grid) {\n  let coords = id.split(\"-\");\n  let x = parseInt(coords[0]);\n  let y = parseInt(coords[1]);\n  let neighbors = [];\n  let neighbor; // North\n\n  if (grid[x - 1] && grid[x - 1][y]) {\n    neighbor = `${(x - 1).toString()}-${y.toString()}`;\n    if (nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n  } // South\n\n\n  if (grid[x + 1] && grid[x + 1][y]) {\n    neighbor = `${(x + 1).toString()}-${y.toString()}`;\n    if (nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n  }\n\n  if (grid[x][y - 1]) {\n    neighbor = `${x.toString()}-${(y - 1).toString()}`;\n    if (nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n  }\n\n  if (grid[x][y + 1]) {\n    neighbor = `${x.toString()}-${(y + 1).toString()}`;\n    if (nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n  }\n\n  return neighbors;\n}\n\nfunction getPathCost(nodeA, nodeB) {\n  let startCoords = nodeA.id.split(\"-\");\n  let targetCoords = nodeB.id.split(\"-\");\n  let nodeAx = parseInt(startCoords[0]);\n  let nodeAy = parseInt(startCoords[1]);\n  let nodeBx = parseInt(targetCoords[0]);\n  let nodeBy = parseInt(targetCoords[1]); // B is above A\n\n  if (nodeBx < nodeAx && nodeAy === nodeBy) {\n    if (nodeA.direction === \"N\") return [1, [\"f\"], \"N\"];else if (nodeA.direction === \"E\") return [2, [\"l\", \"f\"], \"N\"];else if (nodeA.direction === \"W\") return [2, [\"r\", \"f\"], \"N\"];else if (nodeA.direction === \"S\") return [3, [\"r\", \"r\", \"f\"], \"N\"];else if (nodeA.direction === \"NE\") return [1.5, null, \"N\"];else if (nodeA.direction === \"SE\") return [2.5, null, \"N\"];else if (nodeA.direction === \"NW\") return [1.5, null, \"N\"];else if (nodeA.direction === \"SW\") return [2.5, null, \"N\"];\n  } else if (nodeBx > nodeAx && nodeAy === nodeBy) {\n    if (nodeA.direction === \"N\") return [3, [\"r\", \"r\", \"f\"], \"S\"];else if (nodeA.direction === \"E\") return [2, [\"r\", \"f\"], \"S\"];else if (nodeA.direction === \"W\") return [2, [\"l\", \"f\"], \"S\"];else if (nodeA.direction === \"S\") return [1, [\"f\"], \"S\"];else if (nodeA.direction === \"NE\") return [2.5, null, \"S\"];else if (nodeA.direction === \"SE\") return [1.5, null, \"S\"];else if (nodeA.direction === \"NW\") return [2.5, null, \"S\"];else if (nodeA.direction === \"SW\") return [1.5, null, \"S\"];\n  }\n\n  if (nodeBy < nodeAy && nodeAx === nodeBx) {\n    if (nodeA.direction === \"N\") return [2, [\"l\", \"f\"], \"W\"];else if (nodeA.direction === \"E\") return [3, [\"l\", \"l\", \"f\"], \"W\"];else if (nodeA.direction === \"W\") return [1, [\"f\"], \"W\"];else if (nodeA.direction === \"S\") return [2, [\"r\", \"f\"], \"W\"];else if (nodeA.direction === \"NE\") return [2.5, null, \"W\"];else if (nodeA.direction === \"SE\") return [2.5, null, \"W\"];else if (nodeA.direction === \"NW\") return [1.5, null, \"W\"];else if (nodeA.direction === \"SW\") return [1.5, null, \"W\"];\n  } else if (nodeBy > nodeAy && nodeAx === nodeBx) {\n    if (nodeA.direction === \"N\") return [2, [\"r\", \"f\"], \"E\"];else if (nodeA.direction === \"E\") return [1, [\"f\"], \"E\"];else if (nodeA.direction === \"W\") return [3, [\"r\", \"r\", \"f\"], \"E\"];else if (nodeA.direction === \"S\") return [2, [\"l\", \"f\"], \"E\"];else if (nodeA.direction === \"NE\") return [1.5, null, \"E\"];else if (nodeA.direction === \"SE\") return [1.5, null, \"E\"];else if (nodeA.direction === \"NW\") return [2.5, null, \"E\"];else if (nodeA.direction === \"SW\") return [2.5, null, \"E\"];\n  }\n}\n\nfunction manhattanDistance(nodeA, nodeB) {\n  let nodeAcoords = nodeA.id.split(\"-\").map(x => parseInt(x));\n  let nodeBcoords = nodeB.id.split(\"-\").map(x => parseInt(x));\n  let nodeAx = nodeAcoords[0];\n  let nodeBx = nodeBcoords[0];\n  let nodeAy = nodeAcoords[1];\n  let nodeBy = nodeBcoords[1];\n  let delta_x = Math.abs(nodeAx - nodeBx);\n  let delta_y = Math.abs(nodeAy - nodeBy);\n  return delta_x + delta_y;\n}\n\nexport function getAstarPath(goal) {\n  const path = [];\n  let tmpNode = goal;\n\n  while (tmpNode !== null) {\n    path.unshift(tmpNode);\n    tmpNode = tmpNode.previousNode;\n  }\n\n  return path;\n}","map":{"version":3,"sources":["/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/astar.js"],"names":["astar","nodes","start","goal","explored","grid","heuristic","id","g","f","direction","frontier","Object","keys","console","log","length","node","closestNode","status","Infinity","push","updateNeighbors","index","i","h","splice","target","neighbors","getNeighbors","neighbor","updateNode","tmpTarget","trueStart","trueTarget","path","getPathCost","manhattanDistance","dist","weight","previousNode","coords","split","x","parseInt","y","toString","nodeA","nodeB","startCoords","targetCoords","nodeAx","nodeAy","nodeBx","nodeBy","nodeAcoords","map","nodeBcoords","delta_x","Math","abs","delta_y","getAstarPath","tmpNode","unshift"],"mappings":"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","sourcesContent":["// A* Search Algorithm\n//  - Allowable Moves: [N, E, S, W]\n//  - Inputs\n//      - Adjacency Matrix\n//      - Start Node\n//      - Goal Node\n//  - Output:\n//      - Guarenteed shortest possible path\nexport function astar(nodes, start, goal, explored, grid, heuristic){\n    if(!start || !goal || start === goal)\n        return false;\n    nodes[start.id].g = 0;\n    nodes[start.id].f = 0;\n    nodes[start.id].direction = \"N\";\n    let frontier = Object.keys(nodes);\n    console.log(\"frontier:\", frontier)\n    while(frontier.length){\n        // Pop the next closest node off the frontier\n        let node = closestNode(nodes, frontier);\n        // Make sure the node is not a wall\n        while(node.status === \"wall\"  && frontier.length){\n            node = closestNode(nodes, frontier);\n        }\n        if(node.g === Infinity) return false;\n        explored.push(node);\n        node.status = \"visited\"\n        if(node.id === goal.id) return explored;\n\n        updateNeighbors(nodes, node, grid, start, goal, heuristic);\n\n    }\n    \n}\n\nfunction closestNode(nodes, frontier){\n    let node, index;\n    for(let i = 0; i < frontier.length; i++){\n        if(!node || node.f > nodes[frontier[i]].f){\n            node = nodes[frontier[i]];\n            index = i;\n        }\n        else if(node.f === nodes[frontier[i]].f){\n            if(node.h > nodes[frontier[i]].h){\n                node = nodes[frontier[i]];\n                index = i;\n            }\n        }\n    }\n    frontier.splice(index, 1);\n    return node;\n}\n\nfunction updateNeighbors(nodes, node, grid, start, target, heuristic){\n    let neighbors = getNeighbors(node.id, nodes, grid);\n    for(let neighbor of neighbors){\n        if(target){\n            // console.log(\"node:\", node);\n            // console.log(\"neighbor:\", neighbor)\n            updateNode(node, nodes[neighbor], nodes[start.id], nodes[target.id], nodes, grid, heuristic);\n        }\n        else{\n            updateNode(node, nodes[neighbor]);\n        }\n    }\n}\n\nfunction updateNode(node, tmpTarget, trueStart, trueTarget, nodes, grid, heuristic){\n    let path = getPathCost(node, tmpTarget);\n    // If our new target node has no heuristic => Assign to be manhattan distance\n    if(!tmpTarget.h) tmpTarget.h = manhattanDistance(tmpTarget, trueTarget);\n    let dist = node.g + tmpTarget.weight + path[0];\n    if(dist < tmpTarget.g){\n        tmpTarget.g = dist;\n        tmpTarget.f = tmpTarget.g + tmpTarget.h\n        tmpTarget.previousNode = node;\n        tmpTarget.path = path[1];\n        tmpTarget.direction = path[2];\n    }\n}\n\nfunction getNeighbors(id, nodes, grid){\n    let coords = id.split(\"-\");\n    let x = parseInt(coords[0]);\n    let y = parseInt(coords[1]);\n    let neighbors = [];\n    let neighbor;\n    // North\n    if(grid[x-1] && grid[x-1][y]){\n        neighbor = `${(x-1).toString()}-${y.toString()}`;\n        if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n    }\n    // South\n    if(grid[x+1] && grid[x+1][y]){\n        neighbor = `${(x+1).toString()}-${y.toString()}`;\n        if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n    }\n    if(grid[x][y-1]){\n        neighbor = `${x.toString()}-${(y - 1).toString()}`;\n        if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n    }\n    if(grid[x][y+1]){\n        neighbor = `${x.toString()}-${(y + 1).toString()}`;\n        if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n    }\n    return neighbors;\n}\n\nfunction getPathCost(nodeA, nodeB){\n    let startCoords = nodeA.id.split(\"-\");\n    let targetCoords = nodeB.id.split(\"-\");\n    let nodeAx = parseInt(startCoords[0]);\n    let nodeAy = parseInt(startCoords[1]);\n    let nodeBx = parseInt(targetCoords[0]);\n    let nodeBy = parseInt(targetCoords[1]);\n    // B is above A\n    if(nodeBx < nodeAx && nodeAy === nodeBy){\n        if(nodeA.direction === \"N\") return [1, [\"f\"], \"N\"];\n        else if(nodeA.direction === \"E\") return [2, [\"l\", \"f\"], \"N\"];\n        else if(nodeA.direction === \"W\") return [2, [\"r\", \"f\"], \"N\"];\n        else if(nodeA.direction === \"S\") return [3, [\"r\", \"r\", \"f\"], \"N\"];\n        else if(nodeA.direction === \"NE\") return [1.5, null, \"N\"];\n        else if(nodeA.direction === \"SE\") return [2.5, null, \"N\"];\n        else if(nodeA.direction === \"NW\") return [1.5, null, \"N\"];\n        else if(nodeA.direction === \"SW\") return [2.5, null, \"N\"];\n    }\n    else if(nodeBx > nodeAx && nodeAy === nodeBy){\n        if(nodeA.direction === \"N\") return [3, [\"r\", \"r\", \"f\"], \"S\"];\n        else if(nodeA.direction === \"E\") return [2, [\"r\", \"f\"], \"S\"];\n        else if(nodeA.direction === \"W\") return [2, [\"l\", \"f\"], \"S\"];\n        else if(nodeA.direction === \"S\") return [1, [\"f\"], \"S\"];\n        else if(nodeA.direction === \"NE\") return [2.5, null, \"S\"];\n        else if(nodeA.direction === \"SE\") return [1.5, null, \"S\"];\n        else if(nodeA.direction === \"NW\") return [2.5, null, \"S\"];\n        else if(nodeA.direction === \"SW\") return [1.5, null, \"S\"];\n    }\n    if(nodeBy < nodeAy && nodeAx === nodeBx){\n        if(nodeA.direction === \"N\") return [2, [\"l\", \"f\"], \"W\"];\n        else if(nodeA.direction === \"E\") return [3, [\"l\", \"l\", \"f\"], \"W\"];\n        else if(nodeA.direction === \"W\") return [1, [\"f\"], \"W\"];\n        else if(nodeA.direction === \"S\") return [2, [\"r\", \"f\"], \"W\"];\n        else if(nodeA.direction === \"NE\") return [2.5, null, \"W\"];\n        else if(nodeA.direction === \"SE\") return [2.5, null, \"W\"];\n        else if(nodeA.direction === \"NW\") return [1.5, null, \"W\"];\n        else if(nodeA.direction === \"SW\") return [1.5, null, \"W\"];\n    }\n    else if(nodeBy > nodeAy && nodeAx === nodeBx){\n        if(nodeA.direction === \"N\") return [2, [\"r\", \"f\"], \"E\"];\n        else if(nodeA.direction === \"E\") return [1, [\"f\"], \"E\"];\n        else if(nodeA.direction === \"W\") return [3, [\"r\",\"r\",\"f\"], \"E\"];\n        else if(nodeA.direction === \"S\") return [2, [\"l\", \"f\"], \"E\"];\n        else if(nodeA.direction === \"NE\") return [1.5, null, \"E\"];\n        else if(nodeA.direction === \"SE\") return [1.5, null, \"E\"];\n        else if(nodeA.direction === \"NW\") return [2.5, null, \"E\"];\n        else if(nodeA.direction === \"SW\") return [2.5, null, \"E\"];\n    }\n}\n\nfunction manhattanDistance(nodeA, nodeB){\n    let nodeAcoords = nodeA.id.split(\"-\").map(x => parseInt(x));\n    let nodeBcoords = nodeB.id.split(\"-\").map(x => parseInt(x));\n    let nodeAx = nodeAcoords[0];\n    let nodeBx = nodeBcoords[0];\n    let nodeAy = nodeAcoords[1];\n    let nodeBy = nodeBcoords[1];\n\n    let delta_x = Math.abs(nodeAx - nodeBx);\n    let delta_y = Math.abs(nodeAy - nodeBy);\n\n    return (delta_x + delta_y);\n}\n\nexport function getAstarPath(goal) {\n    const path = [];\n    let tmpNode = goal;\n    while (tmpNode !== null) {\n      path.unshift(tmpNode);\n      tmpNode = tmpNode.previousNode;\n    }\n    return path;\n  }"]},"metadata":{},"sourceType":"module"}