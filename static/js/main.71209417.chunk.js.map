{"version":3,"sources":["pathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.js","algorithms/astar.js","pathfindingVisualizer/pathfindingVisualizer.jsx","algorithms/dfs.js","algorithms/bfs.js","navbar.jsx","App.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","type","g","h","f","direction","weight","status","id","className","Component","dijkstra","grid","start","goal","visited","frontier","nodes","node","push","getNodes","length","sortNodes","shift","Infinity","isVisited","updateNeighborCosts","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getNeighbors","previousNode","getPath","path","tmpNode","unshift","astar","trueGrid","distance","updateUnvisitedNeighbors","getUnvisitedNeighbors","distanceToFinishNode","PathfindingVisualizer","initGrid","tmpRow","nodeId","newNode","state","mouseDown","algoFinished","currentAlgo","target","board","setState","updateBoard","console","log","document","getElementById","disabled","i","setTimeout","animatePath","algo","innerHTML","clearGrid","getAstarPath","animateSearch","stack","pop","nextNode","dfs","bfs","class","onClick","visualizeSearch","map","rowIdx","nodeIdx","newGrid","slice","newNodes","Navbar","value","event","classList","toggle","algoName","toggleDropdown","href","selectAlgo","window","onclick","matches","dropdowns","getElementsByClassName","openDropdown","contains","remove","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.71209417.chunk.js","sourcesContent":["import React, {Component} from 'react';\nimport './Node.css';\n\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      row,\n      g,\n      h,\n      f,\n      direction,\n      weight,\n      status\n    } = this.props;\n    const type = isFinish\n      ? 'node-finish'\n      : isStart\n      ? 'node-start'\n      : isWall\n      ? 'node-wall'\n      : '';\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${type}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}></div>\n    );\n  }\n}","// Dijkstra's Algorithm:\n//  - Inputs:\n//      - 2D Grid Matrix\n//      - Start Node\n//      - Goal Node\n//  - Output:\n//      - List of nodes representing the shortest possible path, if one exists.\n\nexport function dijkstra(grid, start, goal) {\n    const visited = [];\n    start.g = 0;\n    const frontier = getNodes(grid);\n    while (!!frontier.length) {\n      sortNodes(frontier);\n      // Guarenteed to be next closest node since we've just sorted the unvisited nodes by distance\n      const node = frontier.shift();\n      \n      // Skip checks for any walls\n      if (node.isWall) continue;\n      // If the closest node is infinite distance, then no path exists to our goal\n      if (node.g === Infinity) return visited;\n\n      node.isVisited = true;\n      visited.push(node);\n      if (node === goal) return visited;\n      updateNeighborCosts(node, grid);\n    }\n  }\n  \n  // Sort the nodes by distance\n  function sortNodes(frontier) {\n    frontier.sort((nodeA, nodeB) => nodeA.g - nodeB.g);\n  }\n  \n  function updateNeighborCosts(node, grid) {\n    const unvisitedNeighbors = getNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n      neighbor.g = node.g + 1;\n      neighbor.previousNode = node;\n    }\n  }\n  \n  function getNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n  }\n  \n  function getNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        nodes.push(node);\n      }\n    }\n    return nodes;\n  }\n  \n  // Backtracks from the goal to find the shortest path.\n\n  export function getPath(goal) {\n    const path = [];\n    let tmpNode = goal;\n    while (tmpNode !== null) {\n      path.unshift(tmpNode);\n      tmpNode = tmpNode.previousNode;\n    }\n    return path;\n  }","// // A* Search Algorithm\n// //  - Allowable Moves: [N, E, S, W]\n// //  - Inputs\n// //      - Adjacency Matrix\n// //      - Start Node\n// //      - Goal Node\n// //  - Output:\n// //      - Guarenteed shortest possible path\n// export function astar(nodes, start, goal, explored, grid, heuristic){\n//     if(!start || !goal || start === goal)\n//         return false;\n//     nodes[start.id].g = 0;\n//     nodes[start.id].f = 0;\n//     nodes[start.id].direction = \"N\";\n//     let frontier = Object.keys(nodes);\n//     console.log(\"frontier:\", frontier)\n//     while(frontier.length){\n//         // Pop the next closest node off the frontier\n//         let node = closestNode(nodes, frontier);\n//         // Make sure the node is not a wall\n//         while(node.status === \"wall\"  && frontier.length){\n//             node = closestNode(nodes, frontier);\n//         }\n//         if(node.g === Infinity) return false;\n//         explored.push(node);\n//         node.status = \"visited\";\n//         if(node.id === goal.id) return explored;\n\n//         updateNeighbors(nodes, node, grid, start, goal, heuristic);\n\n//     }\n    \n// }\n\n// function closestNode(nodes, frontier){\n//     let node, index;\n//     for(let i = 0; i < frontier.length; i++){\n//         if(!node || node.f > nodes[frontier[i]].f){\n//             node = nodes[frontier[i]];\n//             index = i;\n//         }\n//         else if(node.f === nodes[frontier[i]].f){\n//             if(node.h > nodes[frontier[i]].h){\n//                 node = nodes[frontier[i]];\n//                 index = i;\n//             }\n//         }\n//     }\n//     frontier.splice(index, 1);\n//     return node;\n// }\n\n// function updateNeighbors(nodes, node, grid, start, target, heuristic){\n//     let neighbors = getNeighbors(node.id, nodes, grid);\n//     for(let neighbor of neighbors){\n//         if(target){\n//             // console.log(\"node:\", node);\n//             // console.log(\"neighbor:\", neighbor)\n//             updateNode(node, nodes[neighbor], nodes[start.id], nodes[target.id], nodes, grid, heuristic);\n//         }\n//         else{\n//             updateNode(node, nodes[neighbor]);\n//         }\n//     }\n// }\n\n// function updateNode(node, tmpTarget, trueStart, trueTarget, nodes, grid, heuristic){\n//     let path = getPathCost(node, tmpTarget);\n//     // If our new target node has no heuristic => Assign to be manhattan distance\n//     if(!tmpTarget.h) tmpTarget.h = manhattanDistance(tmpTarget, trueTarget);\n//     let dist = node.g + tmpTarget.weight + path[0];\n//     if(dist < tmpTarget.g){\n//         tmpTarget.g = dist;\n//         tmpTarget.f = tmpTarget.g + tmpTarget.h\n//         tmpTarget.previousNode = node;\n//         tmpTarget.path = path[1];\n//         tmpTarget.direction = path[2];\n//     }\n// }\n\n// function getNeighbors(id, nodes, grid){\n//     let coords = id.split(\"-\");\n//     let x = parseInt(coords[0]);\n//     let y = parseInt(coords[1]);\n//     let neighbors = [];\n//     let neighbor;\n//     // North\n//     if(grid[x-1] && grid[x-1][y]){\n//         neighbor = `${(x-1).toString()}-${y.toString()}`;\n//         if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n//     }\n//     // South\n//     if(grid[x+1] && grid[x+1][y]){\n//         neighbor = `${(x+1).toString()}-${y.toString()}`;\n//         if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n//     }\n//     if(grid[x][y-1]){\n//         neighbor = `${x.toString()}-${(y - 1).toString()}`;\n//         if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n//     }\n//     if(grid[x][y+1]){\n//         neighbor = `${x.toString()}-${(y + 1).toString()}`;\n//         if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n//     }\n//     return neighbors;\n// }\n\n// function getPathCost(nodeA, nodeB){\n//     let startCoords = nodeA.id.split(\"-\");\n//     let targetCoords = nodeB.id.split(\"-\");\n//     let nodeAx = parseInt(startCoords[0]);\n//     let nodeAy = parseInt(startCoords[1]);\n//     let nodeBx = parseInt(targetCoords[0]);\n//     let nodeBy = parseInt(targetCoords[1]);\n//     // B is above A\n//     if(nodeBx < nodeAx && nodeAy === nodeBy){\n//         if(nodeA.direction === \"N\") return [1, [\"f\"], \"N\"];\n//         else if(nodeA.direction === \"E\") return [2, [\"l\", \"f\"], \"N\"];\n//         else if(nodeA.direction === \"W\") return [2, [\"r\", \"f\"], \"N\"];\n//         else if(nodeA.direction === \"S\") return [3, [\"r\", \"r\", \"f\"], \"N\"];\n//         else if(nodeA.direction === \"NE\") return [1.5, null, \"N\"];\n//         else if(nodeA.direction === \"SE\") return [2.5, null, \"N\"];\n//         else if(nodeA.direction === \"NW\") return [1.5, null, \"N\"];\n//         else if(nodeA.direction === \"SW\") return [2.5, null, \"N\"];\n//     }\n//     else if(nodeBx > nodeAx && nodeAy === nodeBy){\n//         if(nodeA.direction === \"N\") return [3, [\"r\", \"r\", \"f\"], \"S\"];\n//         else if(nodeA.direction === \"E\") return [2, [\"r\", \"f\"], \"S\"];\n//         else if(nodeA.direction === \"W\") return [2, [\"l\", \"f\"], \"S\"];\n//         else if(nodeA.direction === \"S\") return [1, [\"f\"], \"S\"];\n//         else if(nodeA.direction === \"NE\") return [2.5, null, \"S\"];\n//         else if(nodeA.direction === \"SE\") return [1.5, null, \"S\"];\n//         else if(nodeA.direction === \"NW\") return [2.5, null, \"S\"];\n//         else if(nodeA.direction === \"SW\") return [1.5, null, \"S\"];\n//     }\n//     if(nodeBy < nodeAy && nodeAx === nodeBx){\n//         if(nodeA.direction === \"N\") return [2, [\"l\", \"f\"], \"W\"];\n//         else if(nodeA.direction === \"E\") return [3, [\"l\", \"l\", \"f\"], \"W\"];\n//         else if(nodeA.direction === \"W\") return [1, [\"f\"], \"W\"];\n//         else if(nodeA.direction === \"S\") return [2, [\"r\", \"f\"], \"W\"];\n//         else if(nodeA.direction === \"NE\") return [2.5, null, \"W\"];\n//         else if(nodeA.direction === \"SE\") return [2.5, null, \"W\"];\n//         else if(nodeA.direction === \"NW\") return [1.5, null, \"W\"];\n//         else if(nodeA.direction === \"SW\") return [1.5, null, \"W\"];\n//     }\n//     else if(nodeBy > nodeAy && nodeAx === nodeBx){\n//         if(nodeA.direction === \"N\") return [2, [\"r\", \"f\"], \"E\"];\n//         else if(nodeA.direction === \"E\") return [1, [\"f\"], \"E\"];\n//         else if(nodeA.direction === \"W\") return [3, [\"r\",\"r\",\"f\"], \"E\"];\n//         else if(nodeA.direction === \"S\") return [2, [\"l\", \"f\"], \"E\"];\n//         else if(nodeA.direction === \"NE\") return [1.5, null, \"E\"];\n//         else if(nodeA.direction === \"SE\") return [1.5, null, \"E\"];\n//         else if(nodeA.direction === \"NW\") return [2.5, null, \"E\"];\n//         else if(nodeA.direction === \"SW\") return [2.5, null, \"E\"];\n//     }\n// }\n\n// function manhattanDistance(nodeA, nodeB){\n//     let nodeAcoords = nodeA.id.split(\"-\").map(x => parseInt(x));\n//     let nodeBcoords = nodeB.id.split(\"-\").map(x => parseInt(x));\n//     let nodeAx = nodeAcoords[0];\n//     let nodeBx = nodeBcoords[0];\n//     let nodeAy = nodeAcoords[1];\n//     let nodeBy = nodeBcoords[1];\n\n//     let delta_x = Math.abs(nodeAx - nodeBx);\n//     let delta_y = Math.abs(nodeAy - nodeBy);\n\n//     return (delta_x + delta_y);\n// }\n\nexport function astar(trueGrid, start, goal){\n    const grid = {...grid};\n    const visited = [];\n    start.distance = 0;\n    const frontier = getNodes(grid);\n\n    while(frontier.length){\n        sortByDistance(frontier);\n        const node = frontier.shift();\n        if(!node.isWall){\n            if(node.distance === Infinity) return false;\n            node.isVisited = true;\n            visited.push(node);\n            if(node == goal) return visited;\n            updateUnvisitedNeighbors(node, grid);\n        }\n    }\n}\n\nfunction getNodes(grid){\n    const nodes = [];\n    for(const row of grid){\n        for(const node of row){\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\nfunction sortByDistance(unvisitedNodes) {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n      neighbor.distance = node.distance + 1 + neighbor.distanceToFinishNode;\n      neighbor.previousNode = node;\n    }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nexport function getAstarPath(goal) {\n    const path = [];\n    let tmpNode = goal;\n    while (tmpNode !== null) {\n      path.unshift(tmpNode);\n      tmpNode = tmpNode.previousNode;\n    }\n    return path;\n  }\n\n","import React, {Component} from 'react';\nimport Node from './Node/Node';\nimport {dijkstra, getPath} from '../algorithms/dijkstra';\nimport {astar, getAstarPath} from '../algorithms/astar';\nimport './pathfindingVisualizer.css';\nimport {dfs} from '../algorithms/dfs';\nimport { bfs } from '../algorithms/bfs';\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35;\n\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      nodes: {},\n      mouseDown: false,\n      algoFinished: true,\n      currentAlgo: null,\n      start: null,\n      target: null\n    };\n  }\n\n  componentDidMount() {\n    const board = this.initGrid();\n    this.setState({grid: board[0], nodes: board[1]});\n  }\n\n  onMouseDown(row, col) {\n    // const newGrid = updateGrid(this.state.grid, row, col);\n    // const newNodes = updateNodes(this.state.nodes, row, col);\n    const board = updateBoard(this.state.grid, this.state.nodes, row, col);\n    this.setState({grid: board[0], nodes: board[1], mouseDown: true});\n  }\n\n  onMouseEnter(row, col) {\n    if (!this.state.mouseDown) return;\n    // const newGrid = updateGrid(this.state.grid, row, col);\n    // const newNodes = updateNodes(this.state.nodes, row, col);\n    const board = updateBoard(this.state.grid, this.state.nodes, row, col);\n    this.setState({grid: board[0], nodes: board[1]});\n  }\n\n  onMouseUp() {\n    this.setState({mouseDown: false});\n  }\n\n  animateSearch(visited, path) {\n    if(visited === false || path.length === 1 || visited.length === 1){\n      console.log(\"No path found.\")\n      this.algoFinished = true;\n      document.getElementById(\"startButton\").disabled = false;\n      document.getElementById(\"clearGridButton\").disabled = false;\n    }else{\n        for (let i = 0; i <= visited.length; i++) {\n          if (i === visited.length) {\n            setTimeout(() => {\n              this.animatePath(path);\n            }, 10 * i);\n            return;\n          }\n          // Visited nodes get animated in 10ms intervals\n          setTimeout(() => {\n            const node = visited[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n              'node node-visited';\n          }, 10 * i);\n        }\n      }\n    }\n\n  animatePath(path) {\n    for (let i = 0; i < path.length; i++) {\n      setTimeout(() => {\n        const node = path[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-shortest-path';\n      }, 25 * i);\n    }\n    this.algoFinished = true;\n    document.getElementById(\"startButton\").disabled = false;\n    document.getElementById(\"clearGridButton\").disabled = false;\n  }\n\n  visualizeSearch() {\n      const algo = document.getElementById(\"startButton\").innerHTML;\n      if(algo === \"Visualize Algorithm\"){\n        console.log(\"Select an algorithm!\");\n      }\n      else{\n        console.log(\"Selected Algorithm:\", algo);\n\n        // Clear any visited nodes from the grid\n        this.clearGrid();\n        document.getElementById(\"startButton\").disabled = true;\n        document.getElementById(\"clearGridButton\").disabled = true;\n        this.algoFinished = false;\n\n        const {grid, nodes} = this.state;\n        const start = grid[START_NODE_ROW][START_NODE_COL];\n        const goal = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n        var visited = [];\n        var path = [];\n\n        // Select algo based on start button text\n        if(algo === \"A* Search\"){\n          console.log(nodes);\n          // console.log(\"start:\", start)\n          // console.log(\"start-id:\", start.id)\n          // console.log(\"goal:\", goal)\n          //visited = astar(nodes, start, goal, visited, grid, []);\n          visited = astar(grid, start, goal);\n          path = getAstarPath(goal);\n          console.log(\"Astar Visited:\", visited);\n          console.log(\"Astar Path:\", path);\n          this.animateSearch(visited, path);\n        }\n        else if(algo === \"Dijkstra's Algorithm\"){\n          visited = dijkstra(grid, start, goal);\n          path = getPath(goal);\n          console.log(\"Dijkstra Visited:\", visited);\n          console.log(\"Dijkstra Path:\", path);\n          this.animateSearch(visited, path);\n        }else if(algo === \"Depth-First-Search\"){\n          visited = dfs(grid, start, goal);\n          path = getPath(goal);\n          console.log(\"DFS Visited:\", visited);\n          console.log(\"DFS Path:\", path);\n          this.animateSearch(visited, path);\n        }else if(algo === \"Breadth-First-Search\"){\n          visited = bfs(grid, start, goal);\n          path = getPath(goal);\n          console.log(\"BFS Visited:\", visited);\n          console.log(\"BFS Path:\", path);\n          this.animateSearch(visited, path);\n        }\n      }\n  }\n  // Same as init grid, exept walls & start/goal nodes are kept\n  clearGrid() {\n    if(this.algoFinished){\n      for(let row = 0; row < 20; row++) {\n        for (let col = 0; col < 50; col++) {\n          this.state.grid[row][col].previousNode = null;\n          this.state.grid[row][col].isVisited = false;\n          if(row === START_NODE_ROW && col === START_NODE_COL){\n            document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n          }\n          else if(row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\n            document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n          }\n          else if(document.getElementById(`node-${row}-${col}`).className === \"node node-visited\"){\n            document.getElementById(`node-${row}-${col}`).className = 'node';\n          }\n          else if(document.getElementById(`node-${row}-${col}`).className === \"node node-shortest-path\"){\n            document.getElementById(`node-${row}-${col}`).className = 'node';\n          }\n        }\n      }\n    }\n  }\n  // Initialize New Grid\n  initGrid = () => {\n    var grid = [];\n    var nodes = {};\n    for (let row = 0; row < 20; row++) {\n      const tmpRow = [];\n      for (let col = 0; col < 50; col++) {\n        var nodeId = `${row}-${col}`, nodeClass, node;\n        var node = newNode(col, row);\n\n        if(row === START_NODE_ROW && col === START_NODE_COL){\n          node.status = \"start\"\n        } \n        else if(row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\n          node.status = \"target\"\n        } \n        else node.status = \"node\"\n\n        tmpRow.push(node);\n        nodes[nodeId] = node;\n      }\n      grid.push(tmpRow);\n    }\n    return [grid, nodes];\n  };\n\n  render() {\n    const {grid, mouseDown, algoFinished} = this.state;\n    let tableHTML = \"\";\n    return (\n      <>\n        <div class=\"board\">\n        <div class=\"center\">\n          <button id=\"startButton\" onClick={() => this.visualizeSearch()}>Visualize Algorithm</button>\n        </div>\n        <div class=\"center\">\n          <button id=\"clearGridButton\" onClick={() => this.initGrid()}>Reset Grid</button>\n        </div>\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const {row, col, isFinish, isStart, isWall} = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      g = {Infinity}\n                      h = {null}\n                      f = {Infinity}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      mouseDown={mouseDown}\n                      onMouseDown={(row, col) => this.onMouseDown(row, col)}\n                      onMouseEnter={(row, col) => this.onMouseEnter(row, col)}\n                      onMouseUp={() => this.onMouseUp()}\n                      row={row}></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n        </div>\n      </>\n    );\n  }\n}\n// Create a new Node\nconst newNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    g: Infinity,\n    h: null,\n    f: Infinity,\n    status: null,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n    weight: 0,\n    id: `${row}-${col}`\n  };\n};\n// Update our grid state\nconst updateBoard = (grid, nodes, row, col) => {\n  // Create copies of grid & nodes\n  const newGrid = grid.slice();\n  const newNodes = nodes;\n  // If start/goal node, continue\n  if(row === START_NODE_ROW && col === START_NODE_COL \n    || row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\n    return [grid, nodes];\n  }\n  // Get the node in question\n  const node = newGrid[row][col];\n  // Create a new node with prop \"isWall\" toggled\n  const newNode = {\n    ...node,\n   isWall: !node.isWall,\n  };\n  // Set status to wall if .isWall === true\n  if(newNode.isWall) newNode.status = \"wall\";\n  else newNode.status = \"node\";\n  // Update the new node in the grid & nodes sets, then return to be updated as state\n  newNodes[`${row}-${col}`] = newNode;\n  newGrid[row][col] = newNode;\n\n  return [newGrid, newNodes];\n};","export function dfs(grid, start, goal){\n    const visited = [];\n    let stack = [start];\n    while(stack.length){\n        const node = stack.pop();\n        if(node.id === goal.id) return visited;\n\n        if(!node.isWall && (node.isStart || !node.isVisited)){\n            node.isVisited = true;\n            visited.push(node);\n            const {col, row} = node;\n            let nextNode;\n            if(row > 0){\n                nextNode = grid[row-1][col];\n                if(!nextNode.isVisited){\n                    nextNode.previousNode = node;\n                    stack.push(nextNode);\n                }\n            }\n            if(row < grid.length - 1){\n                nextNode = grid[row+1][col];\n                if(!nextNode.isVisited){\n                    nextNode.previousNode = node;\n                    stack.push(nextNode);\n                }\n            }\n            if(col > 0){\n                nextNode = grid[row][col-1];\n                if(!nextNode.isVisited){\n                    nextNode.previousNode = node;\n                    stack.push(nextNode);\n                }\n            }\n            if(col < grid[0].length-1){\n                nextNode = grid[row][col+1];\n                if(!nextNode.isVisited){\n                    nextNode.previousNode = node;\n                    stack.push(nextNode);\n                }\n            }\n        }\n    }\n    return visited;\n}","export function bfs(grid, start, goal){\n    const visited = [];\n    let stack = [start];\n    while(stack.length){\n        const node = stack.shift();\n        if(node.id === goal.id) return visited;\n\n        if(!node.isWall && (node.isStart || !node.isVisited)){\n            node.isVisited = true;\n            visited.push(node);\n            const {col, row} = node;\n            let nextNode;\n            if(row > 0){\n                nextNode = grid[row-1][col];\n                if(!nextNode.isVisited){\n                    nextNode.previousNode = node;\n                    stack.push(nextNode);\n                }\n            }\n            if(row < grid.length - 1){\n                nextNode = grid[row+1][col];\n                if(!nextNode.isVisited){\n                    nextNode.previousNode = node;\n                    stack.push(nextNode);\n                }\n            }\n            if(col > 0){\n                nextNode = grid[row][col-1];\n                if(!nextNode.isVisited){\n                    nextNode.previousNode = node;\n                    stack.push(nextNode);\n                }\n            }\n            if(col < grid[0].length-1){\n                nextNode = grid[row][col+1];\n                if(!nextNode.isVisited){\n                    nextNode.previousNode = node;\n                    stack.push(nextNode);\n                }\n            }\n        }\n    }\n    return visited;\n}","import React, {Component} from 'react';\nimport './navbar.css';\n\nexport default class Navbar extends Component{\n\n    constructor(props){\n        super(props);\n        this.state = {value: props.value};\n    }\n\n    handleChange(event){\n        this.setState({value: event.target.value});\n    }\n    \n    toggleDropdown(){\n        document.getElementById(\"myDropdown\").classList.toggle(\"show\");\n    }\n\n    selectAlgo(algoName){\n        this.toggleDropdown();\n        document.getElementById(\"startButton\").innerHTML = algoName;\n    }\n\n    render(){\n        return(\n            <div class=\"navbar\">\n                <div class=\"dropdown\">\n                    <button onClick={() => this.toggleDropdown()} class=\"dropbtn\">Select an Algorithm</button>\n                    <div id=\"myDropdown\" class=\"dropdown-content\">\n                        <a href=\"#\" id=\"dijkstraStart\" onClick={() => this.selectAlgo(\"Dijkstra's Algorithm\")}>Dijkstra's Algorithm</a>\n                        <a href=\"#\" id=\"astarStart\" onClick={() => this.selectAlgo(\"A* Search\")}>A* Search</a>\n                        <a href=\"#\" id=\"bfsStart\" onClick={() => this.selectAlgo(\"Breadth-First-Search\")}>BFS</a>\n                        <a href=\"#\" id=\"dfsStart\" onClick={() => this.selectAlgo(\"Depth-First-Search\")}>DFS</a>\n                    </div>\n                </div>\n            </div>\n        )\n    }\n\n}    \n// Close the dropdown menu if the user clicks outside of it\nwindow.onclick = function(event) {\n    if (!event.target.matches('.dropbtn')) {\n    var dropdowns = document.getElementsByClassName(\"dropdown-content\");\n    var i;\n    for (i = 0; i < dropdowns.length; i++) {\n        var openDropdown = dropdowns[i];\n        if (openDropdown.classList.contains('show')) {\n        openDropdown.classList.remove('show');\n        }\n    }\n    }\n}","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './pathfindingVisualizer/pathfindingVisualizer';\nimport Navbar from './navbar';\n\nfunction App() {\n  return (    \n    <div className=\"App\">\n      <Navbar></Navbar>\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div> \n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));"],"sourceRoot":""}