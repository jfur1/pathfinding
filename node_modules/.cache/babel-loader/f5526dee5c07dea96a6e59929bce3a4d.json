{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";// A* Search Algorithm\n//  - Allowable Moves: [N, E, S, W]\n//  - Inputs\n//      - Adjacency Matrix\n//      - Start Node\n//      - Goal Node\n//  - Output:\n//      - Guarenteed shortest possible path\nexport function astar(nodes,start,goal,explored,grid,heuristic){if(!start||!goal||start===goal)return false;nodes[start.id].g=0;nodes[start.id].f=0;nodes[start.id].direction=\"N\";var frontier=Object.keys(nodes);console.log(\"frontier:\",frontier);while(frontier.length){// Pop the next closest node off the frontier\nvar node=closestNode(nodes,frontier);// Make sure the node is not a wall\nwhile(node.status===\"wall\"&&frontier.length){node=closestNode(nodes,frontier);}if(node.g===Infinity)return false;explored.push(node);node.status=\"visited\";if(node.id===goal.id)return explored;updateNeighbors(nodes,node,grid,start,goal,heuristic);}}function closestNode(nodes,frontier){var node,index;for(var i=0;i<frontier.length;i++){if(!node||node.f>nodes[frontier[i]].f){node=nodes[frontier[i]];index=i;}else if(node.f===nodes[frontier[i]].f){if(node.h>nodes[frontier[i]].h){node=nodes[frontier[i]];index=i;}}}frontier.splice(index,1);return node;}function updateNeighbors(nodes,node,grid,start,target,heuristic){var neighbors=getNeighbors(node.id,nodes,grid);var _iterator=_createForOfIteratorHelper(neighbors),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var neighbor=_step.value;if(target){// console.log(\"node:\", node);\n// console.log(\"neighbor:\", neighbor)\nupdateNode(node,nodes[neighbor],nodes[start.id],nodes[target.id],nodes,grid,heuristic);}else{updateNode(node,nodes[neighbor]);}}}catch(err){_iterator.e(err);}finally{_iterator.f();}}function updateNode(node,tmpTarget,trueStart,trueTarget,nodes,grid,heuristic){var path=getPathCost(node,tmpTarget);// If our new target node has no heuristic => Assign to be manhattan distance\nif(!tmpTarget.h)tmpTarget.h=manhattanDistance(tmpTarget,trueTarget);var dist=node.g+tmpTarget.weight+path[0];if(dist<tmpTarget.g){tmpTarget.g=dist;tmpTarget.f=tmpTarget.g+tmpTarget.h;tmpTarget.previousNode=node;tmpTarget.path=path[1];tmpTarget.direction=path[2];}}function getNeighbors(id,nodes,grid){var coords=id.split(\"-\");var x=parseInt(coords[0]);var y=parseInt(coords[1]);var neighbors=[];var neighbor;// North\nif(grid[x-1]&&grid[x-1][y]){neighbor=\"\".concat((x-1).toString(),\"-\").concat(y.toString());if(nodes[neighbor].status!==\"wall\")neighbors.push(neighbor);}// South\nif(grid[x+1]&&grid[x+1][y]){neighbor=\"\".concat((x+1).toString(),\"-\").concat(y.toString());if(nodes[neighbor].status!==\"wall\")neighbors.push(neighbor);}if(grid[x][y-1]){neighbor=\"\".concat(x.toString(),\"-\").concat((y-1).toString());if(nodes[neighbor].status!==\"wall\")neighbors.push(neighbor);}if(grid[x][y+1]){neighbor=\"\".concat(x.toString(),\"-\").concat((y+1).toString());if(nodes[neighbor].status!==\"wall\")neighbors.push(neighbor);}return neighbors;}function getPathCost(nodeA,nodeB){var startCoords=nodeA.id.split(\"-\");var targetCoords=nodeB.id.split(\"-\");var nodeAx=parseInt(startCoords[0]);var nodeAy=parseInt(startCoords[1]);var nodeBx=parseInt(targetCoords[0]);var nodeBy=parseInt(targetCoords[1]);// B is above A\nif(nodeBx<nodeAx&&nodeAy===nodeBy){if(nodeA.direction===\"N\")return[1,[\"f\"],\"N\"];else if(nodeA.direction===\"E\")return[2,[\"l\",\"f\"],\"N\"];else if(nodeA.direction===\"W\")return[2,[\"r\",\"f\"],\"N\"];else if(nodeA.direction===\"S\")return[3,[\"r\",\"r\",\"f\"],\"N\"];else if(nodeA.direction===\"NE\")return[1.5,null,\"N\"];else if(nodeA.direction===\"SE\")return[2.5,null,\"N\"];else if(nodeA.direction===\"NW\")return[1.5,null,\"N\"];else if(nodeA.direction===\"SW\")return[2.5,null,\"N\"];}else if(nodeBx>nodeAx&&nodeAy===nodeBy){if(nodeA.direction===\"N\")return[3,[\"r\",\"r\",\"f\"],\"S\"];else if(nodeA.direction===\"E\")return[2,[\"r\",\"f\"],\"S\"];else if(nodeA.direction===\"W\")return[2,[\"l\",\"f\"],\"S\"];else if(nodeA.direction===\"S\")return[1,[\"f\"],\"S\"];else if(nodeA.direction===\"NE\")return[2.5,null,\"S\"];else if(nodeA.direction===\"SE\")return[1.5,null,\"S\"];else if(nodeA.direction===\"NW\")return[2.5,null,\"S\"];else if(nodeA.direction===\"SW\")return[1.5,null,\"S\"];}if(nodeBy<nodeAy&&nodeAx===nodeBx){if(nodeA.direction===\"N\")return[2,[\"l\",\"f\"],\"W\"];else if(nodeA.direction===\"E\")return[3,[\"l\",\"l\",\"f\"],\"W\"];else if(nodeA.direction===\"W\")return[1,[\"f\"],\"W\"];else if(nodeA.direction===\"S\")return[2,[\"r\",\"f\"],\"W\"];else if(nodeA.direction===\"NE\")return[2.5,null,\"W\"];else if(nodeA.direction===\"SE\")return[2.5,null,\"W\"];else if(nodeA.direction===\"NW\")return[1.5,null,\"W\"];else if(nodeA.direction===\"SW\")return[1.5,null,\"W\"];}else if(nodeBy>nodeAy&&nodeAx===nodeBx){if(nodeA.direction===\"N\")return[2,[\"r\",\"f\"],\"E\"];else if(nodeA.direction===\"E\")return[1,[\"f\"],\"E\"];else if(nodeA.direction===\"W\")return[3,[\"r\",\"r\",\"f\"],\"E\"];else if(nodeA.direction===\"S\")return[2,[\"l\",\"f\"],\"E\"];else if(nodeA.direction===\"NE\")return[1.5,null,\"E\"];else if(nodeA.direction===\"SE\")return[1.5,null,\"E\"];else if(nodeA.direction===\"NW\")return[2.5,null,\"E\"];else if(nodeA.direction===\"SW\")return[2.5,null,\"E\"];}}function manhattanDistance(nodeA,nodeB){var nodeAcoords=nodeA.id.split(\"-\").map(function(x){return parseInt(x);});var nodeBcoords=nodeB.id.split(\"-\").map(function(x){return parseInt(x);});var nodeAx=nodeAcoords[0];var nodeBx=nodeBcoords[0];var nodeAy=nodeAcoords[1];var nodeBy=nodeBcoords[1];var delta_x=Math.abs(nodeAx-nodeBx);var delta_y=Math.abs(nodeAy-nodeBy);return delta_x+delta_y;}export function getAstarPath(goal){var path=[];var tmpNode=goal;while(tmpNode!==null){path.unshift(tmpNode);tmpNode=tmpNode.previousNode;}return path;}","map":{"version":3,"sources":["/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/astar.js"],"names":["astar","nodes","start","goal","explored","grid","heuristic","id","g","f","direction","frontier","Object","keys","console","log","length","node","closestNode","status","Infinity","push","updateNeighbors","index","i","h","splice","target","neighbors","getNeighbors","neighbor","updateNode","tmpTarget","trueStart","trueTarget","path","getPathCost","manhattanDistance","dist","weight","previousNode","coords","split","x","parseInt","y","toString","nodeA","nodeB","startCoords","targetCoords","nodeAx","nodeAy","nodeBx","nodeBy","nodeAcoords","map","nodeBcoords","delta_x","Math","abs","delta_y","getAstarPath","tmpNode","unshift"],"mappings":"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","sourcesContent":["// A* Search Algorithm\n//  - Allowable Moves: [N, E, S, W]\n//  - Inputs\n//      - Adjacency Matrix\n//      - Start Node\n//      - Goal Node\n//  - Output:\n//      - Guarenteed shortest possible path\nexport function astar(nodes, start, goal, explored, grid, heuristic){\n    if(!start || !goal || start === goal)\n        return false;\n    nodes[start.id].g = 0;\n    nodes[start.id].f = 0;\n    nodes[start.id].direction = \"N\";\n    let frontier = Object.keys(nodes);\n    console.log(\"frontier:\", frontier)\n    while(frontier.length){\n        // Pop the next closest node off the frontier\n        let node = closestNode(nodes, frontier);\n        // Make sure the node is not a wall\n        while(node.status === \"wall\"  && frontier.length){\n            node = closestNode(nodes, frontier);\n        }\n        if(node.g === Infinity) return false;\n        explored.push(node);\n        node.status = \"visited\"\n        if(node.id === goal.id) return explored;\n\n        updateNeighbors(nodes, node, grid, start, goal, heuristic);\n\n    }\n    \n}\n\nfunction closestNode(nodes, frontier){\n    let node, index;\n    for(let i = 0; i < frontier.length; i++){\n        if(!node || node.f > nodes[frontier[i]].f){\n            node = nodes[frontier[i]];\n            index = i;\n        }\n        else if(node.f === nodes[frontier[i]].f){\n            if(node.h > nodes[frontier[i]].h){\n                node = nodes[frontier[i]];\n                index = i;\n            }\n        }\n    }\n    frontier.splice(index, 1);\n    return node;\n}\n\nfunction updateNeighbors(nodes, node, grid, start, target, heuristic){\n    let neighbors = getNeighbors(node.id, nodes, grid);\n    for(let neighbor of neighbors){\n        if(target){\n            // console.log(\"node:\", node);\n            // console.log(\"neighbor:\", neighbor)\n            updateNode(node, nodes[neighbor], nodes[start.id], nodes[target.id], nodes, grid, heuristic);\n        }\n        else{\n            updateNode(node, nodes[neighbor]);\n        }\n    }\n}\n\nfunction updateNode(node, tmpTarget, trueStart, trueTarget, nodes, grid, heuristic){\n    let path = getPathCost(node, tmpTarget);\n    // If our new target node has no heuristic => Assign to be manhattan distance\n    if(!tmpTarget.h) tmpTarget.h = manhattanDistance(tmpTarget, trueTarget);\n    let dist = node.g + tmpTarget.weight + path[0];\n    if(dist < tmpTarget.g){\n        tmpTarget.g = dist;\n        tmpTarget.f = tmpTarget.g + tmpTarget.h\n        tmpTarget.previousNode = node;\n        tmpTarget.path = path[1];\n        tmpTarget.direction = path[2];\n    }\n}\n\nfunction getNeighbors(id, nodes, grid){\n    let coords = id.split(\"-\");\n    let x = parseInt(coords[0]);\n    let y = parseInt(coords[1]);\n    let neighbors = [];\n    let neighbor;\n    // North\n    if(grid[x-1] && grid[x-1][y]){\n        neighbor = `${(x-1).toString()}-${y.toString()}`;\n        if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n    }\n    // South\n    if(grid[x+1] && grid[x+1][y]){\n        neighbor = `${(x+1).toString()}-${y.toString()}`;\n        if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n    }\n    if(grid[x][y-1]){\n        neighbor = `${x.toString()}-${(y - 1).toString()}`;\n        if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n    }\n    if(grid[x][y+1]){\n        neighbor = `${x.toString()}-${(y + 1).toString()}`;\n        if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n    }\n    return neighbors;\n}\n\nfunction getPathCost(nodeA, nodeB){\n    let startCoords = nodeA.id.split(\"-\");\n    let targetCoords = nodeB.id.split(\"-\");\n    let nodeAx = parseInt(startCoords[0]);\n    let nodeAy = parseInt(startCoords[1]);\n    let nodeBx = parseInt(targetCoords[0]);\n    let nodeBy = parseInt(targetCoords[1]);\n    // B is above A\n    if(nodeBx < nodeAx && nodeAy === nodeBy){\n        if(nodeA.direction === \"N\") return [1, [\"f\"], \"N\"];\n        else if(nodeA.direction === \"E\") return [2, [\"l\", \"f\"], \"N\"];\n        else if(nodeA.direction === \"W\") return [2, [\"r\", \"f\"], \"N\"];\n        else if(nodeA.direction === \"S\") return [3, [\"r\", \"r\", \"f\"], \"N\"];\n        else if(nodeA.direction === \"NE\") return [1.5, null, \"N\"];\n        else if(nodeA.direction === \"SE\") return [2.5, null, \"N\"];\n        else if(nodeA.direction === \"NW\") return [1.5, null, \"N\"];\n        else if(nodeA.direction === \"SW\") return [2.5, null, \"N\"];\n    }\n    else if(nodeBx > nodeAx && nodeAy === nodeBy){\n        if(nodeA.direction === \"N\") return [3, [\"r\", \"r\", \"f\"], \"S\"];\n        else if(nodeA.direction === \"E\") return [2, [\"r\", \"f\"], \"S\"];\n        else if(nodeA.direction === \"W\") return [2, [\"l\", \"f\"], \"S\"];\n        else if(nodeA.direction === \"S\") return [1, [\"f\"], \"S\"];\n        else if(nodeA.direction === \"NE\") return [2.5, null, \"S\"];\n        else if(nodeA.direction === \"SE\") return [1.5, null, \"S\"];\n        else if(nodeA.direction === \"NW\") return [2.5, null, \"S\"];\n        else if(nodeA.direction === \"SW\") return [1.5, null, \"S\"];\n    }\n    if(nodeBy < nodeAy && nodeAx === nodeBx){\n        if(nodeA.direction === \"N\") return [2, [\"l\", \"f\"], \"W\"];\n        else if(nodeA.direction === \"E\") return [3, [\"l\", \"l\", \"f\"], \"W\"];\n        else if(nodeA.direction === \"W\") return [1, [\"f\"], \"W\"];\n        else if(nodeA.direction === \"S\") return [2, [\"r\", \"f\"], \"W\"];\n        else if(nodeA.direction === \"NE\") return [2.5, null, \"W\"];\n        else if(nodeA.direction === \"SE\") return [2.5, null, \"W\"];\n        else if(nodeA.direction === \"NW\") return [1.5, null, \"W\"];\n        else if(nodeA.direction === \"SW\") return [1.5, null, \"W\"];\n    }\n    else if(nodeBy > nodeAy && nodeAx === nodeBx){\n        if(nodeA.direction === \"N\") return [2, [\"r\", \"f\"], \"E\"];\n        else if(nodeA.direction === \"E\") return [1, [\"f\"], \"E\"];\n        else if(nodeA.direction === \"W\") return [3, [\"r\",\"r\",\"f\"], \"E\"];\n        else if(nodeA.direction === \"S\") return [2, [\"l\", \"f\"], \"E\"];\n        else if(nodeA.direction === \"NE\") return [1.5, null, \"E\"];\n        else if(nodeA.direction === \"SE\") return [1.5, null, \"E\"];\n        else if(nodeA.direction === \"NW\") return [2.5, null, \"E\"];\n        else if(nodeA.direction === \"SW\") return [2.5, null, \"E\"];\n    }\n}\n\nfunction manhattanDistance(nodeA, nodeB){\n    let nodeAcoords = nodeA.id.split(\"-\").map(x => parseInt(x));\n    let nodeBcoords = nodeB.id.split(\"-\").map(x => parseInt(x));\n    let nodeAx = nodeAcoords[0];\n    let nodeBx = nodeBcoords[0];\n    let nodeAy = nodeAcoords[1];\n    let nodeBy = nodeBcoords[1];\n\n    let delta_x = Math.abs(nodeAx - nodeBx);\n    let delta_y = Math.abs(nodeAy - nodeBy);\n\n    return (delta_x + delta_y);\n}\n\nexport function getAstarPath(goal) {\n    const path = [];\n    let tmpNode = goal;\n    while (tmpNode !== null) {\n      path.unshift(tmpNode);\n      tmpNode = tmpNode.previousNode;\n    }\n    return path;\n  }"]},"metadata":{},"sourceType":"module"}