[{"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/index.js":"1","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/App.js":"2","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/navbar.jsx":"3","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/pathfindingVisualizer/pathfindingVisualizer.jsx":"4","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/astar.js":"5","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/dijkstra.js":"6","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/pathfindingVisualizer/Node/Node.jsx":"7","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/bfs.js":"8","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/dfs.js":"9"},{"size":167,"mtime":1609794319429,"results":"10","hashOfConfig":"11"},{"size":338,"mtime":1609796579757,"results":"12","hashOfConfig":"11"},{"size":1810,"mtime":1609989992895,"results":"13","hashOfConfig":"11"},{"size":26053,"mtime":1609989891329,"results":"14","hashOfConfig":"11"},{"size":8412,"mtime":1609986602895,"results":"15","hashOfConfig":"11"},{"size":2076,"mtime":1609830298898,"results":"16","hashOfConfig":"11"},{"size":732,"mtime":1609796579759,"results":"17","hashOfConfig":"11"},{"size":1398,"mtime":1609966021968,"results":"18","hashOfConfig":"11"},{"size":1396,"mtime":1609966341759,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"1entc3h",{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"27","messages":"28","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"29","messages":"30","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31","usedDeprecatedRules":"22"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36","usedDeprecatedRules":"37"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/index.js",[],["42","43"],"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/App.js",[],"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/navbar.jsx",["44","45","46","47"],"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/pathfindingVisualizer/pathfindingVisualizer.jsx",["48","49","50","51"],"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/astar.js",["52"],"// A* Search Algorithm\n//  - Allowable Moves: [N, E, S, W]\n//  - Inputs\n//      - Adjacency Matrix\n//      - Start Node\n//      - Goal Node\n//  - Output:\n//      - Guarenteed shortest possible path\nexport function astar(nodes, start, goal, explored, grid, heuristic){\n    if(!start || !goal || start === goal)\n        return false;\n    nodes[start.id].g = 0;\n    nodes[start.id].f = 0;\n    nodes[start.id].direction = \"N\";\n    let frontier = Object.keys(nodes);\n    console.log(\"frontier:\", frontier)\n    while(frontier.length){\n        // Pop the next closest node off the frontier\n        let node = closestNode(nodes, frontier);\n        // Make sure the node is not a wall\n        while(node.status === \"wall\"  && frontier.length){\n            node = closestNode(nodes, frontier);\n        }\n        if(node.g === Infinity) return false;\n        explored.push(node);\n        node.status = \"visited\";\n        if(node.id === goal.id) return explored;\n\n        updateNeighbors(nodes, node, grid, start, goal, heuristic);\n\n    }\n    \n}\n\nfunction closestNode(nodes, frontier){\n    let node, index;\n    for(let i = 0; i < frontier.length; i++){\n        if(!node || node.f > nodes[frontier[i]].f){\n            node = nodes[frontier[i]];\n            index = i;\n        }\n        else if(node.f === nodes[frontier[i]].f){\n            if(node.h > nodes[frontier[i]].h){\n                node = nodes[frontier[i]];\n                index = i;\n            }\n        }\n    }\n    frontier.splice(index, 1);\n    return node;\n}\n\nfunction updateNeighbors(nodes, node, grid, start, target, heuristic){\n    let neighbors = getNeighbors(node.id, nodes, grid);\n    for(let neighbor of neighbors){\n        if(target){\n            // console.log(\"node:\", node);\n            // console.log(\"neighbor:\", neighbor)\n            updateNode(node, nodes[neighbor], nodes[start.id], nodes[target.id], nodes, grid, heuristic);\n        }\n        else{\n            updateNode(node, nodes[neighbor]);\n        }\n    }\n}\n\nfunction updateNode(node, tmpTarget, trueStart, trueTarget, nodes, grid, heuristic){\n    let path = getPathCost(node, tmpTarget);\n    // If our new target node has no heuristic => Assign to be manhattan distance\n    if(!tmpTarget.h) tmpTarget.h = manhattanDistance(tmpTarget, trueTarget);\n    let dist = node.g + tmpTarget.weight + path[0];\n    if(dist < tmpTarget.g){\n        tmpTarget.g = dist;\n        tmpTarget.f = tmpTarget.g + tmpTarget.h\n        tmpTarget.previousNode = node;\n        tmpTarget.path = path[1];\n        tmpTarget.direction = path[2];\n    }\n}\n\nfunction getNeighbors(id, nodes, grid){\n    let coords = id.split(\"-\");\n    let x = parseInt(coords[0]);\n    let y = parseInt(coords[1]);\n    let neighbors = [];\n    let neighbor;\n    // North\n    if(grid[x-1] && grid[x-1][y]){\n        neighbor = `${(x-1).toString()}-${y.toString()}`;\n        if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n    }\n    // South\n    if(grid[x+1] && grid[x+1][y]){\n        neighbor = `${(x+1).toString()}-${y.toString()}`;\n        if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n    }\n    if(grid[x][y-1]){\n        neighbor = `${x.toString()}-${(y - 1).toString()}`;\n        if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n    }\n    if(grid[x][y+1]){\n        neighbor = `${x.toString()}-${(y + 1).toString()}`;\n        if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n    }\n    return neighbors;\n}\n\nfunction getPathCost(nodeA, nodeB){\n    let startCoords = nodeA.id.split(\"-\");\n    let targetCoords = nodeB.id.split(\"-\");\n    let nodeAx = parseInt(startCoords[0]);\n    let nodeAy = parseInt(startCoords[1]);\n    let nodeBx = parseInt(targetCoords[0]);\n    let nodeBy = parseInt(targetCoords[1]);\n    // B is above A\n    if(nodeBx < nodeAx && nodeAy === nodeBy){\n        if(nodeA.direction === \"N\") return [1, [\"f\"], \"N\"];\n        else if(nodeA.direction === \"E\") return [2, [\"l\", \"f\"], \"N\"];\n        else if(nodeA.direction === \"W\") return [2, [\"r\", \"f\"], \"N\"];\n        else if(nodeA.direction === \"S\") return [3, [\"r\", \"r\", \"f\"], \"N\"];\n        else if(nodeA.direction === \"NE\") return [1.5, null, \"N\"];\n        else if(nodeA.direction === \"SE\") return [2.5, null, \"N\"];\n        else if(nodeA.direction === \"NW\") return [1.5, null, \"N\"];\n        else if(nodeA.direction === \"SW\") return [2.5, null, \"N\"];\n    }\n    else if(nodeBx > nodeAx && nodeAy === nodeBy){\n        if(nodeA.direction === \"N\") return [3, [\"r\", \"r\", \"f\"], \"S\"];\n        else if(nodeA.direction === \"E\") return [2, [\"r\", \"f\"], \"S\"];\n        else if(nodeA.direction === \"W\") return [2, [\"l\", \"f\"], \"S\"];\n        else if(nodeA.direction === \"S\") return [1, [\"f\"], \"S\"];\n        else if(nodeA.direction === \"NE\") return [2.5, null, \"S\"];\n        else if(nodeA.direction === \"SE\") return [1.5, null, \"S\"];\n        else if(nodeA.direction === \"NW\") return [2.5, null, \"S\"];\n        else if(nodeA.direction === \"SW\") return [1.5, null, \"S\"];\n    }\n    if(nodeBy < nodeAy && nodeAx === nodeBx){\n        if(nodeA.direction === \"N\") return [2, [\"l\", \"f\"], \"W\"];\n        else if(nodeA.direction === \"E\") return [3, [\"l\", \"l\", \"f\"], \"W\"];\n        else if(nodeA.direction === \"W\") return [1, [\"f\"], \"W\"];\n        else if(nodeA.direction === \"S\") return [2, [\"r\", \"f\"], \"W\"];\n        else if(nodeA.direction === \"NE\") return [2.5, null, \"W\"];\n        else if(nodeA.direction === \"SE\") return [2.5, null, \"W\"];\n        else if(nodeA.direction === \"NW\") return [1.5, null, \"W\"];\n        else if(nodeA.direction === \"SW\") return [1.5, null, \"W\"];\n    }\n    else if(nodeBy > nodeAy && nodeAx === nodeBx){\n        if(nodeA.direction === \"N\") return [2, [\"r\", \"f\"], \"E\"];\n        else if(nodeA.direction === \"E\") return [1, [\"f\"], \"E\"];\n        else if(nodeA.direction === \"W\") return [3, [\"r\",\"r\",\"f\"], \"E\"];\n        else if(nodeA.direction === \"S\") return [2, [\"l\", \"f\"], \"E\"];\n        else if(nodeA.direction === \"NE\") return [1.5, null, \"E\"];\n        else if(nodeA.direction === \"SE\") return [1.5, null, \"E\"];\n        else if(nodeA.direction === \"NW\") return [2.5, null, \"E\"];\n        else if(nodeA.direction === \"SW\") return [2.5, null, \"E\"];\n    }\n}\n\nfunction manhattanDistance(nodeA, nodeB){\n    let nodeAcoords = nodeA.id.split(\"-\").map(x => parseInt(x));\n    let nodeBcoords = nodeB.id.split(\"-\").map(x => parseInt(x));\n    let nodeAx = nodeAcoords[0];\n    let nodeBx = nodeBcoords[0];\n    let nodeAy = nodeAcoords[1];\n    let nodeBy = nodeBcoords[1];\n\n    let delta_x = Math.abs(nodeAx - nodeBx);\n    let delta_y = Math.abs(nodeAy - nodeBy);\n\n    return (delta_x + delta_y);\n}\n\n// export function astar(trueGrid, start, goal){\n//     const grid = {...grid};\n//     const visited = [];\n//     start.distance = 0;\n//     const frontier = getNodes(grid);\n\n//     while(frontier.length){\n//         sortByDistance(frontier);\n//         const node = frontier.shift();\n//         if(!node.isWall){\n//             if(node.distance === Infinity) return false;\n//             node.isVisited = true;\n//             visited.push(node);\n//             if(node == goal) return visited;\n//             updateUnvisitedNeighbors(node, grid);\n//         }\n//     }\n// }\n\nfunction getNodes(grid){\n    const nodes = [];\n    for(const row of grid){\n        for(const node of row){\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\n// function sortByDistance(unvisitedNodes) {\n//     unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n// }\n\n// function updateUnvisitedNeighbors(node, grid) {\n//     const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n//     for (const neighbor of unvisitedNeighbors) {\n//       neighbor.distance = node.distance + 1 + neighbor.distanceToFinishNode;\n//       neighbor.previousNode = node;\n//     }\n// }\n\n// function getUnvisitedNeighbors(node, grid) {\n//     const neighbors = [];\n//     const {col, row} = node;\n//     if (row > 0) neighbors.push(grid[row - 1][col]);\n//     if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n//     if (col > 0) neighbors.push(grid[row][col - 1]);\n//     if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n//     return neighbors.filter(neighbor => !neighbor.isVisited);\n// }\n\nexport function getAstarPath(goal) {\n    const path = [];\n    let tmpNode = goal;\n    while (tmpNode !== null) {\n      path.unshift(tmpNode);\n      tmpNode = tmpNode.previousNode;\n    }\n    return path;\n  }\n\n","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/dijkstra.js",[],"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/pathfindingVisualizer/Node/Node.jsx",["53","54","55","56","57","58"],"import React, {Component} from 'react';\nimport './Node.css';\n\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      row,\n      g,\n      h,\n      f,\n      direction,\n      weight,\n      status\n    } = this.props;\n    const type = isFinish\n      ? 'node-finish'\n      : isStart\n      ? 'node-start'\n      : isWall\n      ? 'node-wall'\n      : '';\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${type}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}></div>\n    );\n  }\n}",["59","60"],"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/bfs.js",[],"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/dfs.js",[],{"ruleId":"61","replacedBy":"62"},{"ruleId":"63","replacedBy":"64"},{"ruleId":"65","severity":1,"message":"66","line":30,"column":25,"nodeType":"67","endLine":30,"endColumn":112},{"ruleId":"65","severity":1,"message":"66","line":31,"column":25,"nodeType":"67","endLine":31,"endColumn":98},{"ruleId":"65","severity":1,"message":"66","line":32,"column":25,"nodeType":"67","endLine":32,"endColumn":107},{"ruleId":"65","severity":1,"message":"66","line":33,"column":25,"nodeType":"67","endLine":33,"endColumn":105},{"ruleId":"68","severity":1,"message":"69","line":9,"column":7,"nodeType":"70","messageId":"71","endLine":9,"endColumn":21},{"ruleId":"68","severity":1,"message":"72","line":10,"column":7,"nodeType":"70","messageId":"71","endLine":10,"endColumn":21},{"ruleId":"68","severity":1,"message":"73","line":11,"column":7,"nodeType":"70","messageId":"71","endLine":11,"endColumn":22},{"ruleId":"68","severity":1,"message":"74","line":12,"column":7,"nodeType":"70","messageId":"71","endLine":12,"endColumn":22},{"ruleId":"68","severity":1,"message":"75","line":191,"column":10,"nodeType":"70","messageId":"71","endLine":191,"endColumn":18},{"ruleId":"68","severity":1,"message":"76","line":15,"column":7,"nodeType":"70","messageId":"71","endLine":15,"endColumn":8},{"ruleId":"68","severity":1,"message":"77","line":16,"column":7,"nodeType":"70","messageId":"71","endLine":16,"endColumn":8},{"ruleId":"68","severity":1,"message":"78","line":17,"column":7,"nodeType":"70","messageId":"71","endLine":17,"endColumn":8},{"ruleId":"68","severity":1,"message":"79","line":18,"column":7,"nodeType":"70","messageId":"71","endLine":18,"endColumn":16},{"ruleId":"68","severity":1,"message":"80","line":19,"column":7,"nodeType":"70","messageId":"71","endLine":19,"endColumn":13},{"ruleId":"68","severity":1,"message":"81","line":20,"column":7,"nodeType":"70","messageId":"71","endLine":20,"endColumn":13},{"ruleId":"61","replacedBy":"82"},{"ruleId":"63","replacedBy":"83"},"no-native-reassign",["84"],"no-negated-in-lhs",["85"],"jsx-a11y/anchor-is-valid","The href attribute requires a valid value to be accessible. Provide a valid, navigable address as the href value. If you cannot provide a valid href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement","no-unused-vars","'START_NODE_ROW' is assigned a value but never used.","Identifier","unusedVar","'START_NODE_COL' is assigned a value but never used.","'FINISH_NODE_ROW' is assigned a value but never used.","'FINISH_NODE_COL' is assigned a value but never used.","'getNodes' is defined but never used.","'g' is assigned a value but never used.","'h' is assigned a value but never used.","'f' is assigned a value but never used.","'direction' is assigned a value but never used.","'weight' is assigned a value but never used.","'status' is assigned a value but never used.",["84"],["85"],"no-global-assign","no-unsafe-negation"]