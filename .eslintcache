[{"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/index.js":"1","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/App.js":"2","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/pathfindingVisualizer/pathfindingVisualizer.jsx":"3","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/astar.js":"4","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/dijkstra.js":"5","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/pathfindingVisualizer/Node/Node.jsx":"6","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/bfs.js":"7","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/dfs.js":"8"},{"size":167,"mtime":1609794319429,"results":"9","hashOfConfig":"10"},{"size":330,"mtime":1610052181397,"results":"11","hashOfConfig":"10"},{"size":20479,"mtime":1610653039754,"results":"12","hashOfConfig":"10"},{"size":1887,"mtime":1610052951229,"results":"13","hashOfConfig":"10"},{"size":1717,"mtime":1610050092881,"results":"14","hashOfConfig":"10"},{"size":666,"mtime":1610050001360,"results":"15","hashOfConfig":"10"},{"size":1443,"mtime":1610050704648,"results":"16","hashOfConfig":"10"},{"size":1494,"mtime":1610050101691,"results":"17","hashOfConfig":"10"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},"1entc3h",{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25","usedDeprecatedRules":"20"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/index.js",[],["37","38"],"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/App.js",[],"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/pathfindingVisualizer/pathfindingVisualizer.jsx",["39","40","41"],"import React, {Component} from 'react';\nimport Node from './Node/Node';\nimport {dijkstra} from '../algorithms/dijkstra';\nimport {astar} from '../algorithms/astar';\nimport {dfs} from '../algorithms/dfs';\nimport { bfs } from '../algorithms/bfs';\nimport './pathfindingVisualizer.css';\n\nexport default class PathfindingVisualizer extends Component {\n  constructor(){\n    super();\n    this.state = {\n      grid: [],\n      START_NODE_ROW: 9,\n      START_NODE_COL: 14,\n      FINISH_NODE_ROW: 9,\n      FINISH_NODE_COL: 32,\n      mousePressed: false,\n      N_ROWS: 20,\n      N_COLS: 50,\n      N_ROWS_MOBILE: 10,\n      N_COLS_MOBILE: 20,\n      isRunning: false,\n      isStartNode: false,\n      isFinishNode: false,\n      isWallNode: false,\n      curRow: 0,\n      curCol: 0,\n      isDesktop: true,\n      visitedAnimationSpeed: 10,\n      shortestPathAnimationSpeed: 40,\n    };\n    // Event Handler Prototypes\n    this.handleMouseDown = this.handleMouseDown.bind(this);\n    this.handleMouseLeave = this.handleMouseLeave.bind(this);\n    this.toggleIsRunning = this.toggleIsRunning.bind(this);\n  }\n\n  componentDidMount() {\n    const grid = this.initGrid();\n    var is_mobile = !!navigator.userAgent.match(/iphone|android|blackberry/ig) || false;\n    if(is_mobile) alert('Mobile version still in development. Try using a computer for the best experience!');\n    this.updateAlgoDescription(\"start\");\n    this.setState({grid});\n  }\n\n  toggleIsRunning() {\n    this.setState({isRunning: !this.state.isRunning});\n  }\n\n  toggleView() {\n    if (!this.state.isRunning) {\n      this.clearGrid();\n      this.clearWalls();\n      const isDesktop = !this.state.isDesktop;\n      let grid;\n      if (isDesktop) {\n        grid = this.initGrid(\n          this.state.N_ROWS,\n          this.state.N_COLS,\n        );\n        this.setState({isDesktop, grid});\n      } else {\n        if (\n          this.state.START_NODE_ROW > this.state.N_ROWS_MOBILE ||\n          this.state.FINISH_NODE_ROW > this.state.N_ROWS_MOBILE ||\n          this.state.START_NODE_COL > this.state.N_COLS_MOBILE ||\n          this.state.FINISH_NODE_COL > this.state.N_COLS_MOBILE\n        ) {\n          alert('Start & Finish Nodes Must Be within 10 Rows x 20 Columns');\n        } else {\n          grid = this.initGrid(\n            this.state.N_ROWS_MOBILE,\n            this.state.N_COLS_MOBILE,\n          );\n          this.setState({isDesktop, grid});\n        }\n      }\n    }\n  }\n\n  toggleDropdown(){\n    if(!this.state.isRunning){\n      document.getElementById(\"myDropdown\").classList.toggle(\"show\");\n    }\n  }\n\n  toggleSpeed(speed){\n      if(!this.state.isRunning){\n        this.toggleDropdown();\n        document.getElementById(\"animation-speed\").innerHTML = `Animation Speed: \\n${speed}`;\n        if(speed === \"Slow\"){\n          this.setState({visitedAnimationSpeed: 25, shortestPathAnimationSpeed: 55});\n        } else if(speed === \"Medium\"){\n          this.setState({visitedAnimationSpeed: 10, shortestPathAnimationSpeed: 40});\n        } else{\n          this.setState({visitedAnimationSpeed: 5, shortestPathAnimationSpeed: 25});\n        }\n      }\n  }\n\n  /* -------------------- Initialize 2D Grid --------------------- */\n  initGrid = (\n    rowCount = this.state.N_ROWS,\n    colCount = this.state.N_COLS,\n  ) => {\n    const initialGrid = [];\n    for (let row = 0; row < rowCount; row++) {\n      const currentRow = [];\n      for (let col = 0; col < colCount; col++) {\n        currentRow.push(this.newNode(row, col));\n      }\n      initialGrid.push(currentRow);\n    }\n    return initialGrid;\n  };\n\n  newNode = (row, col) => {\n    return {\n      row,\n      col,\n      isStart:\n        row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\n      isFinish:\n        row === this.state.FINISH_NODE_ROW &&\n        col === this.state.FINISH_NODE_COL,\n      distance: Infinity,\n      distanceToFinishNode:\n        Math.abs(this.state.FINISH_NODE_ROW - row) +\n        Math.abs(this.state.FINISH_NODE_COL - col),\n      isVisited: false,\n      isWall: false,\n      previousNode: null,\n      isNode: true,\n    };\n  };\n\n  /* --------------------- Mouse Event Handlers ----------------------- */\n  handleMouseDown(row, col) {\n    if (!this.state.isRunning) {\n      if (this.isGridClear()) {\n        if (\n          document.getElementById(`node-${row}-${col}`).className ===\n          'node node-start'\n        ) {\n          this.setState({\n            mousePressed: true,\n            isStartNode: true,\n            curRow: row,\n            curCol: col,\n          });\n        } else if (\n          document.getElementById(`node-${row}-${col}`).className ===\n          'node node-finish'\n        ) {\n          this.setState({\n            mousePressed: true,\n            isFinishNode: true,\n            curRow: row,\n            curCol: col,\n          });\n        } else {\n          const newGrid = updateGrid(this.state.grid, row, col);\n          this.setState({\n            grid: newGrid,\n            mousePressed: true,\n            isWallNode: true,\n            curRow: row,\n            curCol: col,\n          });\n        }\n      } \n    }\n  }\n\n  isGridClear() {\n    for (const row of this.state.grid) {\n      for (const node of row) {\n        const nodeClassName = document.getElementById(\n          `node-${node.row}-${node.col}`,\n        ).className;\n        if (\n          nodeClassName === 'node node-visited' ||\n          nodeClassName === 'node node-shortest-path'\n        ) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.isRunning) {\n      if (this.state.mousePressed) {\n        const nodeClassName = document.getElementById(`node-${row}-${col}`)\n          .className;\n        if (this.state.isStartNode) {\n          if (nodeClassName !== 'node node-wall') {\n            const prevStartNode = this.state.grid[this.state.curRow][\n              this.state.curCol\n            ];\n            prevStartNode.isStart = false;\n            document.getElementById(\n              `node-${this.state.curRow}-${this.state.curCol}`,\n            ).className = 'node';\n\n            this.setState({curRow: row, curCol: col});\n            const currStartNode = this.state.grid[row][col];\n            currStartNode.isStart = true;\n            document.getElementById(`node-${row}-${col}`).className =\n              'node node-start';\n          }\n          this.setState({START_NODE_ROW: row, START_NODE_COL: col});\n        } else if (this.state.isFinishNode) {\n          if (nodeClassName !== 'node node-wall') {\n            const prevFinishNode = this.state.grid[this.state.curRow][\n              this.state.curCol\n            ];\n            prevFinishNode.isFinish = false;\n            document.getElementById(\n              `node-${this.state.curRow}-${this.state.curCol}`,\n            ).className = 'node';\n\n            this.setState({curRow: row, curCol: col});\n            const currFinishNode = this.state.grid[row][col];\n            currFinishNode.isFinish = true;\n            document.getElementById(`node-${row}-${col}`).className =\n              'node node-finish';\n          }\n          this.setState({FINISH_NODE_ROW: row, FINISH_NODE_COL: col});\n        } else if (this.state.isWallNode) {\n          const newGrid = updateGrid(this.state.grid, row, col);\n          this.setState({grid: newGrid});\n        }\n      }\n    }\n  }\n\n  handleMouseUp(row, col) {\n    if (!this.state.isRunning) {\n      this.setState({mousePressed: false});\n      if (this.state.isStartNode) {\n        const isStartNode = !this.state.isStartNode;\n        this.setState({isStartNode, START_NODE_ROW: row, START_NODE_COL: col});\n      } else if (this.state.isFinishNode) {\n        const isFinishNode = !this.state.isFinishNode;\n        this.setState({\n          isFinishNode,\n          FINISH_NODE_ROW: row,\n          FINISH_NODE_COL: col,\n        });\n      }\n      this.initGrid();\n    }\n  }\n\n  handleMouseLeave() {\n    if (this.state.isStartNode) {\n      const isStartNode = !this.state.isStartNode;\n      this.setState({isStartNode, mousePressed: false});\n    } else if (this.state.isFinishNode) {\n      const isFinishNode = !this.state.isFinishNode;\n      this.setState({isFinishNode, mousePressed: false});\n    } else if (this.state.isWallNode) {\n      const isWallNode = !this.state.isWallNode;\n      this.setState({isWallNode, mousePressed: false});\n      this.initGrid();\n    }\n  }\n\n  /* ---------------------- Update Grid / Walls --------------------------- */\n\n  clearGrid() {\n    if (!this.state.isRunning) {\n      const newGrid = this.state.grid.slice();\n      for (const row of newGrid) {\n        for (const node of row) {\n          let className = document.getElementById(\n            `node-${node.row}-${node.col}`,\n          ).className;\n          if (\n            className !== 'node node-start' &&\n            className !== 'node node-finish' &&\n            className !== 'node node-wall'\n          ) {\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n              'node';\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.heuristic =\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\n              Math.abs(this.state.FINISH_NODE_COL - node.col);\n          }\n          if (className === 'node node-finish') {\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.heuristic = 0;\n          }\n          if (className === 'node node-start') {\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.heuristic =\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\n              Math.abs(this.state.FINISH_NODE_COL - node.col);\n            node.isStart = true;\n            node.isWall = false;\n            node.previousNode = null;\n            node.isNode = true;\n          }\n        }\n      }\n    }\n  }\n\n  clearWalls() {\n    if (!this.state.isRunning) {\n      const newGrid = this.state.grid.slice();\n      for (const row of newGrid) {\n        for (const node of row) {\n          let className = document.getElementById(\n            `node-${node.row}-${node.col}`,\n          ).className;\n          if (className === 'node node-wall') {\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n              'node';\n            node.isWall = false;\n          }\n        }\n      }\n    }\n  }\n\n  /* ---------------------------------- Animations ----------------------------- */\n\n  visualize(algo){\n    this.updateAlgoDescription(algo);\n    if (!this.state.isRunning) {\n      this.clearGrid();\n      this.toggleIsRunning();\n      const {grid} = this.state;\n      const start =\n        grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\n      const finish =\n        grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\n      let visitedNodesInOrder;\n      switch (algo) {\n        case 'Dijkstra':\n          visitedNodesInOrder = dijkstra(grid, start, finish);\n          break;\n        case 'astar':\n          visitedNodesInOrder = astar(grid, start, finish);\n          break;\n        case 'BFS':\n          visitedNodesInOrder = bfs(grid, start, finish);\n          break;\n        case 'DFS':\n          visitedNodesInOrder = dfs(grid, start, finish);\n          break;\n        default:\n          // should not execute\n          break;\n      }\n      const path = getPath(finish);\n      path.push('end');\n      this.animate(visitedNodesInOrder, path);\n    }\n  }\n\n  updateAlgoDescription(algo){\n    if (!this.state.isRunning){\n      if(algo === \"Dijkstra\"){\n        document.getElementById('algoDescription').innerHTML = `${algo}'s Algorithm is <i><b>weighted</b></i> and <i><b>does guarantee</b></i> the shortest path!`;\n      }\n      else if(algo === \"astar\"){\n        document.getElementById('algoDescription').innerHTML = `A* Search is <i><b>weighted</b></i> and <i><b>does guarantee</b></i> the shortest path!`;\n      }\n      else if(algo === \"DFS\"){\n        document.getElementById('algoDescription').innerHTML = `Depth-First Search is <i><b>unweighted</b></i> and <i><b>does not guarantee</b></i> the shortest path!`;\n      }\n      else if(algo === \"BFS\"){\n        document.getElementById('algoDescription').innerHTML = `Breadth-First Search is <i><b>unweighted</b></i> and <i><b>does guarantee</b></i> the shortest path!`;\n      }    else{\n        document.getElementById('algoDescription').innerHTML = \"Select an algorithm to visualize!<br><br>Try drawing some walls or moving the start / target nodes!\";\n      }\n    }\n  }\n\n  animate(visitedNodesInOrder, path) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animatePath(path);\n        }, this.state.visitedAnimationSpeed * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        const nodeClass = document.getElementById(\n          `node-${node.row}-${node.col}`,\n        ).className;\n        if (\n          nodeClass !== 'node node-start' &&\n          nodeClass !== 'node node-finish'\n        ) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            'node node-visited';\n        }\n      }, this.state.visitedAnimationSpeed * i);\n    }\n  }\n\n  animatePath(path) {\n    for (let i = 0; i < path.length; i++) {\n      if (path[i] === 'end') {\n        setTimeout(() => {\n          this.toggleIsRunning();\n        }, i * this.state.shortestPathAnimationSpeed);\n      } else {\n        setTimeout(() => {\n          const node = path[i];\n          const nodeClass = document.getElementById(\n            `node-${node.row}-${node.col}`,\n          ).className;\n          if (\n            nodeClass !== 'node node-start' &&\n            nodeClass !== 'node node-finish'\n          ) {\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n              'node node-shortest-path';\n          }\n        }, i * this.state.shortestPathAnimationSpeed);\n      }\n    }\n  }\n\n  /* ------------------------------- Construct Path ----------------------------- */\n    render() {\n      const {grid, mousePressed} = this.state;\n      return (\n        <div>\n          <nav className=\"navbar navbar-expand-lg navbar-dark bg-dark \">\n            <a className=\"navbar-brand\" href=\"https://jfur1.github.io/pathfinding\">\n              <b>PathFinding Visualizer</b>\n            </a>\n            <div className=\"collapse navbar-collapse\" id=\"navbarNav\">\n              <ul className=\"navbar-nav\">\n                <li className=\"nav-item\">\n                  <a\n                    className=\"nav-link\"\n                    href=\"http://www.github.com/jfur1/pathfinding\">\n                    {' '}\n                    PathFinder Visualizer code{' '}\n                  </a>\n                </li>\n                <li className=\"nav-item\">\n                  <a className=\"nav-link\" href=\"https://github.com/jfur1\">\n                    Check Out Other Cool Projects\n                  </a>\n                </li>\n              </ul>\n            </div>\n          </nav>\n          <div id=\"programButtons\">\n          <button\n            type=\"button\"\n            className=\"btn btn-danger mr-1\"\n            onClick={() => this.clearGrid()}>\n            Clear Grid\n          </button>\n          <button\n            type=\"button\"\n            className=\"btn btn-warning mr-1\"\n            onClick={() => this.clearWalls()}>\n            Clear Walls\n          </button>\n          <button\n            type=\"button\"\n            className=\"btn btn-primary mr-1\"\n            onClick={() => this.visualize('Dijkstra')}>\n            Dijkstra's\n          </button>\n          <button\n            type=\"button\"\n            className=\"btn btn-primary mr-1\"\n            onClick={() => this.visualize('astar')}>\n            A*\n          </button>\n          <button\n            type=\"button\"\n            className=\"btn btn-primary mr-1\"\n            onClick={() => this.visualize('BFS')}>\n            Breadth-First Search\n          </button>\n          <button\n            type=\"button\"\n            className=\"btn btn-primary mr-1\"\n            onClick={() => this.visualize('DFS')}>\n            Depth-First Search\n          </button>\n          <div class=\"dropdown\">\n              <button id=\"animation-speed\" onClick={() => this.toggleDropdown()} class=\"dropbtn\">Animation Speed: Medium</button>\n              <div id=\"myDropdown\" class=\"dropdown-content\">\n                  <a href=\"#\" id=\"animate-slow\" onClick={() => this.toggleSpeed(\"Slow\")}>Slow</a>\n                  <a href=\"#\" id=\"animate-medium\" onClick={() => this.toggleSpeed(\"Medium\")}>Medium</a>\n                  <a href=\"#\" id=\"animate-fast\" onClick={() => this.toggleSpeed(\"Fast\")}>Fast</a>\n              </div>\n          </div>\n          {this.state.isDesktopView ? (\n            <button\n              type=\"button\"\n              className=\"btn btn-light mr-1\"\n              onClick={() => this.toggleView()}>\n              Mobile View\n            </button>\n          ) : (\n            <button\n              type=\"button\"\n              className=\"btn btn-dark mr-1\"\n              onClick={() => this.toggleView()}>\n              Desktop View\n            </button>\n          )}\n          </div>\n          <div id=\"legend\">\n            <ul>\n              <li><div class=\"start-legend\"></div>Start Node</li>\n            </ul>\n            <ul>\n              <li><div class=\"target-legend\"></div>Target Node</li>\n            </ul>\n            <ul>\n              <li><div class=\"unvisited-legend\"></div>Unvisited Node</li>\n            </ul>\n            <ul>\n              <li>\n                <div class=\"visited-legend\"></div>\n                <div class=\"visited-legend-2\"></div>\n                Visited Node\n              </li>\n            </ul>\n            <ul>\n              <li><div class=\"wall-legend\"></div>Wall Node</li>\n            </ul>\n            <ul>\n              <li><div class=\"path-legend\"></div>Shortest-Path Node</li>\n            </ul>\n          </div>\n          <div id=\"algoDescription\"></div>\n          <table\n            className=\"grid-container\"\n            onMouseLeave={() => this.handleMouseLeave()}>\n            <tbody className=\"grid\">\n              {grid.map((row, rowIdx) => {\n                return (\n                  <tr key={rowIdx}>\n                    {row.map((node, nodeIdx) => {\n                      const {row, col, isFinish, isStart, isWall} = node;\n                      return (\n                        <Node\n                          key={nodeIdx}\n                          col={col}\n                          isFinish={isFinish}\n                          isStart={isStart}\n                          isWall={isWall}\n                          mousePressed={mousePressed}\n                          onMouseDown={(row, col) =>\n                            this.handleMouseDown(row, col)\n                          }\n                          onMouseEnter={(row, col) =>\n                            this.handleMouseEnter(row, col)\n                          }\n                          onMouseUp={() => this.handleMouseUp(row, col)}\n                          row={row}></Node>\n                      );\n                    })}\n                  </tr>\n                );\n              })}\n            </tbody>\n          </table>\n        </div>\n      );\n    }\n  }\n\n  /******************** Create Walls ********************/\n  const updateGrid = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    if (!node.isStart && !node.isFinish && node.isNode) {\n      const newNode = {\n        ...node,\n        isWall: !node.isWall,\n      };\n      newGrid[row][col] = newNode;\n    }\n    return newGrid;\n  };\n\n  // Backtracks from the goal to find the shortest path.\n  // Only works when called after the pathfinding method has executed.\n  function getPath(goal) {\n    const path = [];\n    let node = goal;\n    while (node !== null) {\n      path.unshift(node);\n      node = node.previousNode;\n    }\n    return path;\n  }\n\n  // Close the dropdown menu if the user clicks outside of it\nwindow.onclick = function(event) {\n  if (!event.target.matches('.dropbtn')) {\n  var dropdowns = document.getElementsByClassName(\"dropdown-content\");\n  var i;\n    for (i = 0; i < dropdowns.length; i++) {\n      var openDropdown = dropdowns[i];\n      if (openDropdown.classList.contains('show')) {\n        openDropdown.classList.remove('show');\n      }\n    }\n  }\n}","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/astar.js",[],"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/dijkstra.js",[],"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/pathfindingVisualizer/Node/Node.jsx",[],["42","43"],"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/bfs.js",[],"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/dfs.js",[],{"ruleId":"44","replacedBy":"45"},{"ruleId":"46","replacedBy":"47"},{"ruleId":"48","severity":1,"message":"49","line":504,"column":19,"nodeType":"50","endLine":504,"endColumn":90},{"ruleId":"48","severity":1,"message":"49","line":505,"column":19,"nodeType":"50","endLine":505,"endColumn":94},{"ruleId":"48","severity":1,"message":"49","line":506,"column":19,"nodeType":"50","endLine":506,"endColumn":90},{"ruleId":"44","replacedBy":"51"},{"ruleId":"46","replacedBy":"52"},"no-native-reassign",["53"],"no-negated-in-lhs",["54"],"jsx-a11y/anchor-is-valid","The href attribute requires a valid value to be accessible. Provide a valid, navigable address as the href value. If you cannot provide a valid href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement",["53"],["54"],"no-global-assign","no-unsafe-negation"]