[{"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/index.js":"1","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/App.js":"2","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/navbar.jsx":"3","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/pathfindingVisualizer/pathfindingVisualizer.jsx":"4","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/astar.js":"5","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/dijkstra.js":"6","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/pathfindingVisualizer/Node/Node.jsx":"7","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/bfs.js":"8","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/dfs.js":"9"},{"size":167,"mtime":1609794319429,"results":"10","hashOfConfig":"11"},{"size":315,"mtime":1609990304703,"results":"12","hashOfConfig":"11"},{"size":1810,"mtime":1609989992895,"results":"13","hashOfConfig":"11"},{"size":26391,"mtime":1609994591537,"results":"14","hashOfConfig":"11"},{"size":8726,"mtime":1609994754305,"results":"15","hashOfConfig":"11"},{"size":3986,"mtime":1609994754919,"results":"16","hashOfConfig":"11"},{"size":686,"mtime":1609993023384,"results":"17","hashOfConfig":"11"},{"size":3006,"mtime":1609994751349,"results":"18","hashOfConfig":"11"},{"size":3020,"mtime":1609994753668,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"1entc3h",{"filePath":"23","messages":"24","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25","usedDeprecatedRules":"22"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"28","usedDeprecatedRules":"22"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31","usedDeprecatedRules":"22"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/index.js",[],["42","43"],"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/App.js",["44"],"import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './pathfindingVisualizer/pathfindingVisualizer';\nimport Navbar from './navbar';\n\nfunction App() {\n  return (    \n    <div className=\"App\">\n\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div> \n  );\n}\n\nexport default App;\n","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/navbar.jsx",["45","46","47","48"],"import React, {Component} from 'react';\nimport './navbar.css';\n\nexport default class Navbar extends Component{\n\n    constructor(props){\n        super(props);\n        this.state = {value: props.value};\n    }\n\n    handleChange(event){\n        this.setState({value: event.target.value});\n    }\n    \n    toggleDropdown(){\n        document.getElementById(\"myDropdown\").classList.toggle(\"show\");\n    }\n\n    selectAlgo(algoName){\n        this.toggleDropdown();\n        document.getElementById(\"startButton\").innerHTML = algoName;\n    }\n\n    render(){\n        return(\n            <div class=\"navbar\">\n                <div class=\"dropdown\">\n                    <button onClick={() => this.toggleDropdown()} class=\"dropbtn\">Select an Algorithm</button>\n                    <div id=\"myDropdown\" class=\"dropdown-content\">\n                        <a href=\"#\" id=\"dijkstraStart\" onClick={() => this.selectAlgo(\"Dijkstra's Algorithm\")}>Dijkstra's Algorithm</a>\n                        <a href=\"#\" id=\"astarStart\" onClick={() => this.selectAlgo(\"A* Search\")}>A* Search</a>\n                        <a href=\"#\" id=\"bfsStart\" onClick={() => this.selectAlgo(\"Breadth-First-Search\")}>BFS</a>\n                        <a href=\"#\" id=\"dfsStart\" onClick={() => this.selectAlgo(\"Depth-First-Search\")}>DFS</a>\n                    </div>\n                </div>\n            </div>\n        )\n    }\n\n}    \n// Close the dropdown menu if the user clicks outside of it\nwindow.onclick = function(event) {\n    if (!event.target.matches('.dropbtn')) {\n    var dropdowns = document.getElementsByClassName(\"dropdown-content\");\n    var i;\n    for (i = 0; i < dropdowns.length; i++) {\n        var openDropdown = dropdowns[i];\n        if (openDropdown.classList.contains('show')) {\n        openDropdown.classList.remove('show');\n        }\n    }\n    }\n}","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/pathfindingVisualizer/pathfindingVisualizer.jsx",["49","50","51","52"],"import React, {Component} from 'react';\nimport Node from './Node/Node';\nimport {dijkstra} from '../algorithms/dijkstra';\nimport {astar} from '../algorithms/astar';\nimport {dfs} from '../algorithms/dfs';\nimport { bfs } from '../algorithms/bfs';\nimport './pathfindingVisualizer.css';\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35;\n\nexport default class PathfindingVisualizer extends Component {\n  constructor(){\n    super();\n    this.state = {\n      grid: [],\n      START_NODE_ROW: 5,\n      START_NODE_COL: 5,\n      FINISH_NODE_ROW: 5,\n      FINISH_NODE_COL: 15,\n      mousePressed: false,\n      N_ROWS: 20,\n      N_COLS: 50,\n      N_ROWS_MOBILE: 10,\n      N_COLS_MOBILE: 20,\n      isRunning: false,\n      isStartNode: false,\n      isFinishNode: false,\n      isWallNode: false,\n      curRow: 0,\n      curCol: 0,\n      isDesktop: true,\n    };\n    // Event Handler Prototypes\n    this.handleMouseDown = this.handleMouseDown.bind(this);\n    this.handleMouseLeave = this.handleMouseLeave.bind(this);\n    this.toggleIsRunning = this.toggleIsRunning.bind(this);\n  }\n\n  componentDidMount() {\n    const grid = this.initGrid();\n    this.setState({grid});\n  }\n\n  toggleIsRunning() {\n    this.setState({isRunning: !this.state.isRunning});\n  }\n\n  toggleView() {\n    if (!this.state.isRunning) {\n      this.clearGrid();\n      this.clearWalls();\n      const isDesktop = !this.state.isDesktop;\n      let grid;\n      if (isDesktop) {\n        grid = this.initGrid(\n          this.state.N_ROWS,\n          this.state.N_COLS,\n        );\n        this.setState({isDesktop, grid});\n      } else {\n        if (\n          this.state.START_NODE_ROW > this.state.N_ROWS_MOBILE ||\n          this.state.FINISH_NODE_ROW > this.state.N_ROWS_MOBILE ||\n          this.state.START_NODE_COL > this.state.N_COLS_MOBILE ||\n          this.state.FINISH_NODE_COL > this.state.N_COLS_MOBILE\n        ) {\n          alert('Start & Finish Nodes Must Be within 10 Rows x 20 Columns');\n        } else {\n          grid = this.initGrid(\n            this.state.N_ROWS_MOBILE,\n            this.state.N_COLS_MOBILE,\n          );\n          this.setState({isDesktop, grid});\n        }\n      }\n    }\n  }\n\n  /* -------------------- Initialize 2D Grid --------------------- */\n  initGrid = (\n    rowCount = this.state.N_ROWS,\n    colCount = this.state.N_COLS,\n  ) => {\n    const initialGrid = [];\n    for (let row = 0; row < rowCount; row++) {\n      const currentRow = [];\n      for (let col = 0; col < colCount; col++) {\n        currentRow.push(this.newNode(row, col));\n      }\n      initialGrid.push(currentRow);\n    }\n    return initialGrid;\n  };\n\n  newNode = (row, col) => {\n    return {\n      row,\n      col,\n      isStart:\n        row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\n      isFinish:\n        row === this.state.FINISH_NODE_ROW &&\n        col === this.state.FINISH_NODE_COL,\n      distance: Infinity,\n      distanceToFinishNode:\n        Math.abs(this.state.FINISH_NODE_ROW - row) +\n        Math.abs(this.state.FINISH_NODE_COL - col),\n      isVisited: false,\n      isWall: false,\n      previousNode: null,\n      isNode: true,\n    };\n  };\n\n  /* --------------------- Mouse Event Handlers ----------------------- */\n  handleMouseDown(row, col) {\n    if (!this.state.isRunning) {\n      if (this.isGridClear()) {\n        if (\n          document.getElementById(`node-${row}-${col}`).className ===\n          'node node-start'\n        ) {\n          this.setState({\n            mousePressed: true,\n            isStartNode: true,\n            curRow: row,\n            curCol: col,\n          });\n        } else if (\n          document.getElementById(`node-${row}-${col}`).className ===\n          'node node-finish'\n        ) {\n          this.setState({\n            mousePressed: true,\n            isFinishNode: true,\n            curRow: row,\n            curCol: col,\n          });\n        } else {\n          const newGrid = updateGrid(this.state.grid, row, col);\n          this.setState({\n            grid: newGrid,\n            mousePressed: true,\n            isWallNode: true,\n            curRow: row,\n            curCol: col,\n          });\n        }\n      } else {\n        this.clearGrid();\n      }\n    }\n  }\n\n  isGridClear() {\n    for (const row of this.state.grid) {\n      for (const node of row) {\n        const nodeClassName = document.getElementById(\n          `node-${node.row}-${node.col}`,\n        ).className;\n        if (\n          nodeClassName === 'node node-visited' ||\n          nodeClassName === 'node node-shortest-path'\n        ) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.isRunning) {\n      if (this.state.mousePressed) {\n        const nodeClassName = document.getElementById(`node-${row}-${col}`)\n          .className;\n        if (this.state.isStartNode) {\n          if (nodeClassName !== 'node node-wall') {\n            const prevStartNode = this.state.grid[this.state.curRow][\n              this.state.curCol\n            ];\n            prevStartNode.isStart = false;\n            document.getElementById(\n              `node-${this.state.curRow}-${this.state.curCol}`,\n            ).className = 'node';\n\n            this.setState({curRow: row, curCol: col});\n            const currStartNode = this.state.grid[row][col];\n            currStartNode.isStart = true;\n            document.getElementById(`node-${row}-${col}`).className =\n              'node node-start';\n          }\n          this.setState({START_NODE_ROW: row, START_NODE_COL: col});\n        } else if (this.state.isFinishNode) {\n          if (nodeClassName !== 'node node-wall') {\n            const prevFinishNode = this.state.grid[this.state.curRow][\n              this.state.curCol\n            ];\n            prevFinishNode.isFinish = false;\n            document.getElementById(\n              `node-${this.state.curRow}-${this.state.curCol}`,\n            ).className = 'node';\n\n            this.setState({curRow: row, curCol: col});\n            const currFinishNode = this.state.grid[row][col];\n            currFinishNode.isFinish = true;\n            document.getElementById(`node-${row}-${col}`).className =\n              'node node-finish';\n          }\n          this.setState({FINISH_NODE_ROW: row, FINISH_NODE_COL: col});\n        } else if (this.state.isWallNode) {\n          const newGrid = updateGrid(this.state.grid, row, col);\n          this.setState({grid: newGrid});\n        }\n      }\n    }\n  }\n\n  handleMouseUp(row, col) {\n    if (!this.state.isRunning) {\n      this.setState({mousePressed: false});\n      if (this.state.isStartNode) {\n        const isStartNode = !this.state.isStartNode;\n        this.setState({isStartNode, START_NODE_ROW: row, START_NODE_COL: col});\n      } else if (this.state.isFinishNode) {\n        const isFinishNode = !this.state.isFinishNode;\n        this.setState({\n          isFinishNode,\n          FINISH_NODE_ROW: row,\n          FINISH_NODE_COL: col,\n        });\n      }\n      this.initGrid();\n    }\n  }\n\n  handleMouseLeave() {\n    if (this.state.isStartNode) {\n      const isStartNode = !this.state.isStartNode;\n      this.setState({isStartNode, mousePressed: false});\n    } else if (this.state.isFinishNode) {\n      const isFinishNode = !this.state.isFinishNode;\n      this.setState({isFinishNode, mousePressed: false});\n    } else if (this.state.isWallNode) {\n      const isWallNode = !this.state.isWallNode;\n      this.setState({isWallNode, mousePressed: false});\n      this.initGrid();\n    }\n  }\n\n  /* ---------------------- Update Grid / Walls --------------------------- */\n\n  clearGrid() {\n    if (!this.state.isRunning) {\n      const newGrid = this.state.grid.slice();\n      for (const row of newGrid) {\n        for (const node of row) {\n          let className = document.getElementById(\n            `node-${node.row}-${node.col}`,\n          ).className;\n          if (\n            className !== 'node node-start' &&\n            className !== 'node node-finish' &&\n            className !== 'node node-wall'\n          ) {\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n              'node';\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.heuristic =\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\n              Math.abs(this.state.FINISH_NODE_COL - node.col);\n          }\n          if (className === 'node node-finish') {\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.heuristic = 0;\n          }\n          if (className === 'node node-start') {\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.heuristic =\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\n              Math.abs(this.state.FINISH_NODE_COL - node.col);\n            node.isStart = true;\n            node.isWall = false;\n            node.previousNode = null;\n            node.isNode = true;\n          }\n        }\n      }\n    }\n  }\n\n  clearWalls() {\n    if (!this.state.isRunning) {\n      const newGrid = this.state.grid.slice();\n      for (const row of newGrid) {\n        for (const node of row) {\n          let className = document.getElementById(\n            `node-${node.row}-${node.col}`,\n          ).className;\n          if (className === 'node node-wall') {\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n              'node';\n            node.isWall = false;\n          }\n        }\n      }\n    }\n  }\n\n  /* ---------------------------------- Animations ----------------------------- */\n\n  visualize(algo){\n    if (!this.state.isRunning) {\n      this.clearGrid();\n      this.toggleIsRunning();\n      const {grid} = this.state;\n      const start =\n        grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\n      const finish =\n        grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\n      let visitedNodesInOrder;\n      switch (algo) {\n        case 'Dijkstra':\n          visitedNodesInOrder = dijkstra(grid, start, finish);\n          break;\n        case 'astar':\n          visitedNodesInOrder = astar(grid, start, finish);\n          break;\n        case 'BFS':\n          visitedNodesInOrder = bfs(grid, start, finish);\n          break;\n        case 'DFS':\n          visitedNodesInOrder = dfs(grid, start, finish);\n          break;\n        default:\n          // should not execute\n          break;\n      }\n      const path = getPath(finish);\n      path.push('end');\n      this.animate(visitedNodesInOrder, path);\n    }\n  }\n\n  animate(visitedNodesInOrder, path) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animatePath(path);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        const nodeClass = document.getElementById(\n          `node-${node.row}-${node.col}`,\n        ).className;\n        if (\n          nodeClass !== 'node node-start' &&\n          nodeClass !== 'node node-finish'\n        ) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            'node node-visited';\n        }\n      }, 10 * i);\n    }\n  }\n\n  animatePath(path) {\n    for (let i = 0; i < path.length; i++) {\n      if (path[i] === 'end') {\n        setTimeout(() => {\n          this.toggleIsRunning();\n        }, i * 50);\n      } else {\n        setTimeout(() => {\n          const node = path[i];\n          const nodeClass = document.getElementById(\n            `node-${node.row}-${node.col}`,\n          ).className;\n          if (\n            nodeClass !== 'node node-start' &&\n            nodeClass !== 'node node-finish'\n          ) {\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n              'node node-shortest-path';\n          }\n        }, i * 40);\n      }\n    }\n  }\n\n  /* ------------------------------- Construct Path ----------------------------- */\n    render() {\n      const {grid, mousePressed} = this.state;\n      return (\n        <div>\n          <nav className=\"navbar navbar-expand-lg navbar-dark bg-dark \">\n            <a className=\"navbar-brand\" href=\"/\">\n              <b>PathFinding Visualizer</b>\n            </a>\n            <button\n              className=\"navbar-toggler\"\n              type=\"button\"\n              data-toggle=\"collapse\"\n              data-target=\"#navbarNav\"\n              aria-controls=\"navbarNav\"\n              aria-expanded=\"false\"\n              aria-label=\"Toggle navigation\">\n              <span className=\"navbar-toggler-icon\"></span>\n            </button>\n            <div className=\"collapse navbar-collapse\" id=\"navbarNav\">\n              <ul className=\"navbar-nav\">\n                <li className=\"nav-item\">\n                  <a\n                    className=\"nav-link\"\n                    href=\"http://www.github.com/jfur1/pathfinding\">\n                    {' '}\n                    PathFinder Visualizer code{' '}\n                  </a>\n                </li>\n                <li className=\"nav-item\">\n                  <a className=\"nav-link\" href=\"https://jfur1.github.com\">\n                    Check Out Other Cool Projects\n                  </a>\n                </li>\n              </ul>\n            </div>\n          </nav>\n\n          <table\n            className=\"grid-container\"\n            onMouseLeave={() => this.handleMouseLeave()}>\n            <tbody className=\"grid\">\n              {grid.map((row, rowIdx) => {\n                return (\n                  <tr key={rowIdx}>\n                    {row.map((node, nodeIdx) => {\n                      const {row, col, isFinish, isStart, isWall} = node;\n                      return (\n                        <Node\n                          key={nodeIdx}\n                          col={col}\n                          isFinish={isFinish}\n                          isStart={isStart}\n                          isWall={isWall}\n                          mousePressed={mousePressed}\n                          onMouseDown={(row, col) =>\n                            this.handleMouseDown(row, col)\n                          }\n                          onMouseEnter={(row, col) =>\n                            this.handleMouseEnter(row, col)\n                          }\n                          onMouseUp={() => this.handleMouseUp(row, col)}\n                          row={row}></Node>\n                      );\n                    })}\n                  </tr>\n                );\n              })}\n            </tbody>\n          </table>\n          <button\n            type=\"button\"\n            className=\"btn btn-danger\"\n            onClick={() => this.clearGrid()}>\n            Clear Grid\n          </button>\n          <button\n            type=\"button\"\n            className=\"btn btn-warning\"\n            onClick={() => this.clearWalls()}>\n            Clear Walls\n          </button>\n          <button\n            type=\"button\"\n            className=\"btn btn-primary\"\n            onClick={() => this.visualize('Dijkstra')}>\n            Dijkstra's\n          </button>\n          <button\n            type=\"button\"\n            className=\"btn btn-primary\"\n            onClick={() => this.visualize('astar')}>\n            A*\n          </button>\n          <button\n            type=\"button\"\n            className=\"btn btn-primary\"\n            onClick={() => this.visualize('BFS')}>\n            Breadth-First Search\n          </button>\n          <button\n            type=\"button\"\n            className=\"btn btn-primary\"\n            onClick={() => this.visualize('DFS')}>\n            Depth-First Search\n          </button>\n          {this.state.isDesktopView ? (\n            <button\n              type=\"button\"\n              className=\"btn btn-light\"\n              onClick={() => this.toggleView()}>\n              Mobile View\n            </button>\n          ) : (\n            <button\n              type=\"button\"\n              className=\"btn btn-dark\"\n              onClick={() => this.toggleView()}>\n              Desktop View\n            </button>\n          )}\n        </div>\n      );\n    }\n  }\n\n\n  /******************** Create Walls ********************/\n  const updateGrid = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    if (!node.isStart && !node.isFinish && node.isNode) {\n      const newNode = {\n        ...node,\n        isWall: !node.isWall,\n      };\n      newGrid[row][col] = newNode;\n    }\n    return newGrid;\n  };\n\n  // Backtracks from the goal to find the shortest path.\n  // Only works when called after the pathfinding method has executed.\n  function getPath(goal) {\n    const path = [];\n    let node = goal;\n    while (node !== null) {\n      path.unshift(node);\n      node = node.previousNode;\n    }\n    return path;\n  }\n\n// export default class PathfindingVisualizer extends Component {\n//   constructor() {\n//     super();\n//     this.state = {\n//       grid: [],\n//       nodes: {},\n//       mouseDown: false,\n//       algoFinished: true,\n//       currentAlgo: null,\n//       start: null,\n//       target: null\n//     };\n//   }\n\n//   componentDidMount() {\n//     const board = this.initGrid();\n//     this.setState({grid: board[0], nodes: board[1]});\n//   }\n\n//   onMouseDown(row, col) {\n//     // const newGrid = updateGrid(this.state.grid, row, col);\n//     // const newNodes = updateNodes(this.state.nodes, row, col);\n//     const board = updateBoard(this.state.grid, this.state.nodes, row, col);\n//     this.setState({grid: board[0], nodes: board[1], mouseDown: true});\n//   }\n\n//   onMouseEnter(row, col) {\n//     if (!this.state.mouseDown) return;\n//     // const newGrid = updateGrid(this.state.grid, row, col);\n//     // const newNodes = updateNodes(this.state.nodes, row, col);\n//     const board = updateBoard(this.state.grid, this.state.nodes, row, col);\n//     this.setState({grid: board[0], nodes: board[1]});\n//   }\n\n//   onMouseUp() {\n//     this.setState({mouseDown: false});\n//   }\n\n//   animateSearch(visited, path) {\n//     if(visited === false || path.length === 1 || visited.length === 1){\n//       console.log(\"No path found.\")\n//       this.algoFinished = true;\n//       document.getElementById(\"startButton\").disabled = false;\n//       document.getElementById(\"clearGridButton\").disabled = false;\n//     }else{\n//         for (let i = 0; i <= visited.length; i++) {\n//           if (i === visited.length) {\n//             setTimeout(() => {\n//               this.animatePath(path);\n//             }, 10 * i);\n//             return;\n//           }\n//           // Visited nodes get animated in 10ms intervals\n//           setTimeout(() => {\n//             const node = visited[i];\n//             document.getElementById(`node-${node.row}-${node.col}`).className =\n//               'node node-visited';\n//           }, 10 * i);\n//         }\n//       }\n//     }\n\n//   animatePath(path) {\n//     for (let i = 0; i < path.length; i++) {\n//       setTimeout(() => {\n//         const node = path[i];\n//         document.getElementById(`node-${node.row}-${node.col}`).className =\n//           'node node-shortest-path';\n//       }, 25 * i);\n//     }\n//     this.algoFinished = true;\n//     document.getElementById(\"startButton\").disabled = false;\n//     document.getElementById(\"clearGridButton\").disabled = false;\n//   }\n\n//   visualizeSearch() {\n//       const algo = document.getElementById(\"startButton\").innerHTML;\n//       if(algo === \"Visualize Algorithm\"){\n//         console.log(\"Select an algorithm!\");\n//       }\n//       else{\n//         console.log(\"Selected Algorithm:\", algo);\n\n//         // Clear any visited nodes from the grid\n//         this.clearGrid();\n//         document.getElementById(\"startButton\").disabled = true;\n//         document.getElementById(\"clearGridButton\").disabled = true;\n//         this.algoFinished = false;\n\n//         const {grid, nodes} = this.state;\n//         const start = grid[START_NODE_ROW][START_NODE_COL];\n//         const goal = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n//         var visited = [];\n//         var path = [];\n\n//         // Select algo based on start button text\n//         if(algo === \"A* Search\"){\n//           console.log(nodes);\n//           // console.log(\"start:\", start)\n//           // console.log(\"start-id:\", start.id)\n//           // console.log(\"goal:\", goal)\n//           //visited = astar(nodes, start, goal, visited, grid, []);\n//           visited = astar(grid, start, goal);\n//           path = getAstarPath(goal);\n//           console.log(\"Astar Visited:\", visited);\n//           console.log(\"Astar Path:\", path);\n//           this.animateSearch(visited, path);\n//         }\n//         else if(algo === \"Dijkstra's Algorithm\"){\n//           visited = dijkstra(grid, start, goal);\n//           path = getPath(goal);\n//           console.log(\"Dijkstra Visited:\", visited);\n//           console.log(\"Dijkstra Path:\", path);\n//           this.animateSearch(visited, path);\n//         }else if(algo === \"Depth-First-Search\"){\n//           visited = dfs(grid, start, goal);\n//           path = getPath(goal);\n//           console.log(\"DFS Visited:\", visited);\n//           console.log(\"DFS Path:\", path);\n//           this.animateSearch(visited, path);\n//         }else if(algo === \"Breadth-First-Search\"){\n//           visited = bfs(grid, start, goal);\n//           path = getPath(goal);\n//           console.log(\"BFS Visited:\", visited);\n//           console.log(\"BFS Path:\", path);\n//           this.animateSearch(visited, path);\n//         }\n//       }\n//   }\n//   // Same as init grid, exept walls & start/goal nodes are kept\n//   clearGrid() {\n//     if(this.algoFinished){\n//       for(let row = 0; row < 20; row++) {\n//         for (let col = 0; col < 50; col++) {\n//           this.state.grid[row][col].previousNode = null;\n//           this.state.grid[row][col].isVisited = false;\n//           if(row === START_NODE_ROW && col === START_NODE_COL){\n//             document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n//           }\n//           else if(row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\n//             document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n//           }\n//           else if(document.getElementById(`node-${row}-${col}`).className === \"node node-visited\"){\n//             document.getElementById(`node-${row}-${col}`).className = 'node';\n//           }\n//           else if(document.getElementById(`node-${row}-${col}`).className === \"node node-shortest-path\"){\n//             document.getElementById(`node-${row}-${col}`).className = 'node';\n//           }\n//         }\n//       }\n//     }\n//   }\n//   // Initialize New Grid\n//   initGrid = () => {\n//     var grid = [];\n//     var nodes = {};\n//     for (let row = 0; row < 20; row++) {\n//       const tmpRow = [];\n//       for (let col = 0; col < 50; col++) {\n//         var nodeId = `${row}-${col}`, nodeClass, node;\n//         var node = newNode(col, row);\n\n//         if(row === START_NODE_ROW && col === START_NODE_COL){\n//           node.status = \"start\"\n//         } \n//         else if(row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\n//           node.status = \"target\"\n//         } \n//         else node.status = \"node\"\n\n//         tmpRow.push(node);\n//         nodes[nodeId] = node;\n//       }\n//       grid.push(tmpRow);\n//     }\n//     return [grid, nodes];\n//   };\n\n//   render() {\n//     const {grid, mouseDown, algoFinished} = this.state;\n//     let tableHTML = \"\";\n//     return (\n//       <>\n//         <div class=\"board\">\n//         <div class=\"center\">\n//           <button id=\"startButton\" onClick={() => this.visualizeSearch()}>Visualize Algorithm</button>\n//         </div>\n//         <div class=\"center\">\n//           <button id=\"clearGridButton\" onClick={() => this.initGrid()}>Reset Grid</button>\n//         </div>\n//         <div className=\"grid\">\n//           {grid.map((row, rowIdx) => {\n//             return (\n//               <div key={rowIdx}>\n//                 {row.map((node, nodeIdx) => {\n//                   const {row, col, isFinish, isStart, isWall} = node;\n//                   return (\n//                     <Node\n//                       key={nodeIdx}\n//                       col={col}\n//                       g = {Infinity}\n//                       h = {null}\n//                       f = {Infinity}\n//                       isFinish={isFinish}\n//                       isStart={isStart}\n//                       isWall={isWall}\n//                       mouseDown={mouseDown}\n//                       onMouseDown={(row, col) => this.onMouseDown(row, col)}\n//                       onMouseEnter={(row, col) => this.onMouseEnter(row, col)}\n//                       onMouseUp={() => this.onMouseUp()}\n//                       row={row}></Node>\n//                   );\n//                 })}\n//               </div>\n//             );\n//           })}\n//         </div>\n//         </div>\n//       </>\n//     );\n//   }\n// }\n// // Create a new Node\n// const newNode = (col, row) => {\n//   return {\n//     col,\n//     row,\n//     isStart: row === START_NODE_ROW && col === START_NODE_COL,\n//     isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n//     g: Infinity,\n//     h: null,\n//     f: Infinity,\n//     status: null,\n//     isVisited: false,\n//     isWall: false,\n//     previousNode: null,\n//     weight: 0,\n//     id: `${row}-${col}`\n//   };\n// };\n// // Update our grid state\n// const updateBoard = (grid, nodes, row, col) => {\n//   // Create copies of grid & nodes\n//   const newGrid = grid.slice();\n//   const newNodes = nodes;\n//   // If start/goal node, continue\n//   if(row === START_NODE_ROW && col === START_NODE_COL \n//     || row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\n//     return [grid, nodes];\n//   }\n//   // Get the node in question\n//   const node = newGrid[row][col];\n//   // Create a new node with prop \"isWall\" toggled\n//   const newNode = {\n//     ...node,\n//    isWall: !node.isWall,\n//   };\n//   // Set status to wall if .isWall === true\n//   if(newNode.isWall) newNode.status = \"wall\";\n//   else newNode.status = \"node\";\n//   // Update the new node in the grid & nodes sets, then return to be updated as state\n//   newNodes[`${row}-${col}`] = newNode;\n//   newGrid[row][col] = newNode;\n\n//   return [newGrid, newNodes];\n// };","/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/astar.js",["53"],"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/dijkstra.js",[],"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/pathfindingVisualizer/Node/Node.jsx",[],"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/bfs.js",[],"/Users/johnfurlong/Documents/code/Projects/pathfinding-visualizer/pathfinding/src/algorithms/dfs.js",[],{"ruleId":"54","replacedBy":"55"},{"ruleId":"56","replacedBy":"57"},{"ruleId":"58","severity":1,"message":"59","line":4,"column":8,"nodeType":"60","messageId":"61","endLine":4,"endColumn":14},{"ruleId":"62","severity":1,"message":"63","line":30,"column":25,"nodeType":"64","endLine":30,"endColumn":112},{"ruleId":"62","severity":1,"message":"63","line":31,"column":25,"nodeType":"64","endLine":31,"endColumn":98},{"ruleId":"62","severity":1,"message":"63","line":32,"column":25,"nodeType":"64","endLine":32,"endColumn":107},{"ruleId":"62","severity":1,"message":"63","line":33,"column":25,"nodeType":"64","endLine":33,"endColumn":105},{"ruleId":"58","severity":1,"message":"65","line":9,"column":7,"nodeType":"60","messageId":"61","endLine":9,"endColumn":21},{"ruleId":"58","severity":1,"message":"66","line":10,"column":7,"nodeType":"60","messageId":"61","endLine":10,"endColumn":21},{"ruleId":"58","severity":1,"message":"67","line":11,"column":7,"nodeType":"60","messageId":"61","endLine":11,"endColumn":22},{"ruleId":"58","severity":1,"message":"68","line":12,"column":7,"nodeType":"60","messageId":"61","endLine":12,"endColumn":22},{"ruleId":"69","severity":1,"message":"70","line":185,"column":21,"nodeType":"71","messageId":"72","endLine":185,"endColumn":23},"no-native-reassign",["73"],"no-negated-in-lhs",["74"],"no-unused-vars","'Navbar' is defined but never used.","Identifier","unusedVar","jsx-a11y/anchor-is-valid","The href attribute requires a valid value to be accessible. Provide a valid, navigable address as the href value. If you cannot provide a valid href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement","'START_NODE_ROW' is assigned a value but never used.","'START_NODE_COL' is assigned a value but never used.","'FINISH_NODE_ROW' is assigned a value but never used.","'FINISH_NODE_COL' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-global-assign","no-unsafe-negation"]