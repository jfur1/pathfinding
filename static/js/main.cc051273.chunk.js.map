{"version":3,"sources":["pathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.js","algorithms/astar.js","pathfindingVisualizer/pathfindingVisualizer.jsx","navbar.jsx","App.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","type","g","h","f","direction","weight","status","id","className","Component","dijkstra","grid","start","goal","visited","frontier","nodes","node","push","getNodes","length","sortNodes","shift","Infinity","isVisited","updateNeighborCosts","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getNeighbors","previousNode","closestNode","index","i","splice","updateNeighbors","target","heuristic","coords","split","x","parseInt","y","toString","updateNode","tmpTarget","trueStart","trueTarget","path","startCoords","targetCoords","nodeAx","nodeAy","nodeBx","nodeBy","getPathCost","nodeAcoords","map","nodeBcoords","delta_x","Math","abs","delta_y","manhattanDistance","dist","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","PathfindingVisualizer","initGrid","tmpRow","nodeId","newNode","state","mouseDown","algoFinished","currentAlgo","board","setState","newGrid","updateGrid","newNodes","updateNodes","console","log","document","getElementById","disabled","setTimeout","animatePath","algo","innerHTML","explored","Object","keys","astar","tmpNode","unshift","getAstarPath","animateSearch","getPath","class","onClick","visualizeSearch","clearGrid","rowIdx","nodeIdx","slice","Navbar","value","event","classList","toggle","toggleDropdown","href","selectAlgo","window","onclick","matches","dropdowns","getElementsByClassName","openDropdown","contains","remove","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.cc051273.chunk.js","sourcesContent":["import React, {Component} from 'react';\nimport './Node.css';\n\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      row,\n      g,\n      h,\n      f,\n      direction,\n      weight,\n      status\n    } = this.props;\n    const type = isFinish\n      ? 'node-finish'\n      : isStart\n      ? 'node-start'\n      : isWall\n      ? 'node-wall'\n      : '';\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${type}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}></div>\n    );\n  }\n}","// Dijkstra's Algorithm:\n//  - Inputs:\n//      - 2D Grid Matrix\n//      - Start Node\n//      - Goal Node\n//  - Output:\n//      - List of nodes representing the shortest possible path, if one exists.\n\nexport function dijkstra(grid, start, goal) {\n    const visited = [];\n    start.g = 0;\n    const frontier = getNodes(grid);\n    while (!!frontier.length) {\n      sortNodes(frontier);\n      // Guarenteed to be next closest node since we've just sorted the unvisited nodes by distance\n      const node = frontier.shift();\n      \n      // Skip checks for any walls\n      if (node.isWall) continue;\n      // If the closest node is infinite distance, then no path exists to our goal\n      if (node.g === Infinity) return visited;\n\n      node.isVisited = true;\n      visited.push(node);\n      if (node === goal) return visited;\n      updateNeighborCosts(node, grid);\n    }\n  }\n  \n  // Sort the nodes by distance\n  function sortNodes(frontier) {\n    frontier.sort((nodeA, nodeB) => nodeA.g - nodeB.g);\n  }\n  \n  function updateNeighborCosts(node, grid) {\n    const unvisitedNeighbors = getNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n      neighbor.g = node.g + 1;\n      neighbor.previousNode = node;\n    }\n  }\n  \n  function getNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n  }\n  \n  function getNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        nodes.push(node);\n      }\n    }\n    return nodes;\n  }\n  \n  // Backtracks from the goal to find the shortest path.\n\n  export function getPath(goal) {\n    const path = [];\n    let tmpNode = goal;\n    while (tmpNode !== null) {\n      path.unshift(tmpNode);\n      tmpNode = tmpNode.previousNode;\n    }\n    return path;\n  }","// A* Search Algorithm\n//  - Allowable Moves: [N, E, S, W]\n//  - Inputs\n//      - Adjacency Matrix\n//      - Start Node\n//      - Goal Node\n//  - Output:\n//      - Guarenteed shortest possible path\nexport function astar(nodes, start, goal, explored, grid, heuristic){\n    if(!start || !goal || start === goal)\n        return false;\n    nodes[start.id].g = 0;\n    nodes[start.id].f = 0;\n    nodes[start.id].direction = \"N\";\n    let frontier = Object.keys(nodes);\n    console.log(\"frontier:\", frontier)\n    while(frontier.length){\n        // Pop the next closest node off the frontier\n        let node = closestNode(nodes, frontier);\n        // Make sure the node is not a wall\n        while(node.status === \"wall\"  && frontier.length){\n            node = closestNode(nodes, frontier);\n        }\n        if(node.g === Infinity) return false;\n        explored.push(node);\n        node.status = \"visited\"\n        if(node.id === goal.id) return explored;\n\n        updateNeighbors(nodes, node, grid, start, goal, heuristic);\n\n    }\n    \n}\n\nfunction closestNode(nodes, frontier){\n    let node, index;\n    for(let i = 0; i < frontier.length; i++){\n        if(!node || node.f > nodes[frontier[i]].f){\n            node = nodes[frontier[i]];\n            index = i;\n        }\n        else if(node.f === nodes[frontier[i]].f){\n            if(node.h > nodes[frontier[i]].h){\n                node = nodes[frontier[i]];\n                index = i;\n            }\n        }\n    }\n    frontier.splice(index, 1);\n    return node;\n}\n\nfunction updateNeighbors(nodes, node, grid, start, target, heuristic){\n    let neighbors = getNeighbors(node.id, nodes, grid);\n    for(let neighbor of neighbors){\n        if(target){\n            // console.log(\"node:\", node);\n            // console.log(\"neighbor:\", neighbor)\n            updateNode(node, nodes[neighbor], nodes[start.id], nodes[target.id], nodes, grid, heuristic);\n        }\n        else{\n            updateNode(node, nodes[neighbor]);\n        }\n    }\n}\n\nfunction updateNode(node, tmpTarget, trueStart, trueTarget, nodes, grid, heuristic){\n    let path = getPathCost(node, tmpTarget);\n    // If our new target node has no heuristic => Assign to be manhattan distance\n    if(!tmpTarget.h) tmpTarget.h = manhattanDistance(tmpTarget, trueTarget);\n    let dist = node.g + tmpTarget.weight + path[0];\n    if(dist < tmpTarget.g){\n        tmpTarget.g = dist;\n        tmpTarget.f = tmpTarget.g + tmpTarget.h\n        tmpTarget.previousNode = node;\n        tmpTarget.path = path[1];\n        tmpTarget.direction = path[2];\n    }\n}\n\nfunction getNeighbors(id, nodes, grid){\n    let coords = id.split(\"-\");\n    let x = parseInt(coords[0]);\n    let y = parseInt(coords[1]);\n    let neighbors = [];\n    let neighbor;\n    // North\n    if(grid[x-1] && grid[x-1][y]){\n        neighbor = `${(x-1).toString()}-${y.toString()}`;\n        if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n    }\n    // South\n    if(grid[x+1] && grid[x+1][y]){\n        neighbor = `${(x+1).toString()}-${y.toString()}`;\n        if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n    }\n    if(grid[x][y-1]){\n        neighbor = `${x.toString()}-${(y - 1).toString()}`;\n        if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n    }\n    if(grid[x][y+1]){\n        neighbor = `${x.toString()}-${(y + 1).toString()}`;\n        if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n    }\n    return neighbors;\n}\n\nfunction getPathCost(nodeA, nodeB){\n    let startCoords = nodeA.id.split(\"-\");\n    let targetCoords = nodeB.id.split(\"-\");\n    let nodeAx = parseInt(startCoords[0]);\n    let nodeAy = parseInt(startCoords[1]);\n    let nodeBx = parseInt(targetCoords[0]);\n    let nodeBy = parseInt(targetCoords[1]);\n    // B is above A\n    if(nodeBx < nodeAx && nodeAy === nodeBy){\n        if(nodeA.direction === \"N\") return [1, [\"f\"], \"N\"];\n        else if(nodeA.direction === \"E\") return [2, [\"l\", \"f\"], \"N\"];\n        else if(nodeA.direction === \"W\") return [2, [\"r\", \"f\"], \"N\"];\n        else if(nodeA.direction === \"S\") return [3, [\"r\", \"r\", \"f\"], \"N\"];\n        else if(nodeA.direction === \"NE\") return [1.5, null, \"N\"];\n        else if(nodeA.direction === \"SE\") return [2.5, null, \"N\"];\n        else if(nodeA.direction === \"NW\") return [1.5, null, \"N\"];\n        else if(nodeA.direction === \"SW\") return [2.5, null, \"N\"];\n    }\n    else if(nodeBx > nodeAx && nodeAy === nodeBy){\n        if(nodeA.direction === \"N\") return [3, [\"r\", \"r\", \"f\"], \"S\"];\n        else if(nodeA.direction === \"E\") return [2, [\"r\", \"f\"], \"S\"];\n        else if(nodeA.direction === \"W\") return [2, [\"l\", \"f\"], \"S\"];\n        else if(nodeA.direction === \"S\") return [1, [\"f\"], \"S\"];\n        else if(nodeA.direction === \"NE\") return [2.5, null, \"S\"];\n        else if(nodeA.direction === \"SE\") return [1.5, null, \"S\"];\n        else if(nodeA.direction === \"NW\") return [2.5, null, \"S\"];\n        else if(nodeA.direction === \"SW\") return [1.5, null, \"S\"];\n    }\n    if(nodeBy < nodeAy && nodeAx === nodeBx){\n        if(nodeA.direction === \"N\") return [2, [\"l\", \"f\"], \"W\"];\n        else if(nodeA.direction === \"E\") return [3, [\"l\", \"l\", \"f\"], \"W\"];\n        else if(nodeA.direction === \"W\") return [1, [\"f\"], \"W\"];\n        else if(nodeA.direction === \"S\") return [2, [\"r\", \"f\"], \"W\"];\n        else if(nodeA.direction === \"NE\") return [2.5, null, \"W\"];\n        else if(nodeA.direction === \"SE\") return [2.5, null, \"W\"];\n        else if(nodeA.direction === \"NW\") return [1.5, null, \"W\"];\n        else if(nodeA.direction === \"SW\") return [1.5, null, \"W\"];\n    }\n    else if(nodeBy > nodeAy && nodeAx === nodeBx){\n        if(nodeA.direction === \"N\") return [2, [\"r\", \"f\"], \"E\"];\n        else if(nodeA.direction === \"E\") return [1, [\"f\"], \"E\"];\n        else if(nodeA.direction === \"W\") return [3, [\"r\",\"r\",\"f\"], \"E\"];\n        else if(nodeA.direction === \"S\") return [2, [\"l\", \"f\"], \"E\"];\n        else if(nodeA.direction === \"NE\") return [1.5, null, \"E\"];\n        else if(nodeA.direction === \"SE\") return [1.5, null, \"E\"];\n        else if(nodeA.direction === \"NW\") return [2.5, null, \"E\"];\n        else if(nodeA.direction === \"SW\") return [2.5, null, \"E\"];\n    }\n}\n\nfunction manhattanDistance(nodeA, nodeB){\n    let nodeAcoords = nodeA.id.split(\"-\").map(x => parseInt(x));\n    let nodeBcoords = nodeB.id.split(\"-\").map(x => parseInt(x));\n    let nodeAx = nodeAcoords[0];\n    let nodeBx = nodeBcoords[0];\n    let nodeAy = nodeAcoords[1];\n    let nodeBy = nodeBcoords[1];\n\n    let delta_x = Math.abs(nodeAx - nodeBx);\n    let delta_y = Math.abs(nodeAy - nodeBy);\n\n    return (delta_x + delta_y);\n}\n\nexport function getAstarPath(goal) {\n    const path = [];\n    let tmpNode = goal;\n    while (tmpNode !== null) {\n      path.unshift(tmpNode);\n      tmpNode = tmpNode.previousNode;\n    }\n    return path;\n  }","import React, {Component} from 'react';\nimport Node from './Node/Node';\nimport {dijkstra, getPath} from '../algorithms/dijkstra';\nimport {astar, getAstarPath} from '../algorithms/astar';\nimport './pathfindingVisualizer.css';\nimport { nodeName } from 'jquery';\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35;\n\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      nodes: {},\n      mouseDown: false,\n      algoFinished: true,\n      currentAlgo: null,\n      start: null,\n      target: null\n    };\n  }\n\n  componentDidMount() {\n    const board = this.initGrid();\n    this.setState({grid: board[0], nodes: board[1]});\n  }\n\n  onMouseDown(row, col) {\n    const newGrid = updateGrid(this.state.grid, row, col);\n    const newNodes = updateNodes(this.state.nodes, row, col);\n    this.setState({grid: newGrid, nodes: newNodes, mouseDown: true});\n  }\n\n  onMouseEnter(row, col) {\n    if (!this.state.mouseDown) return;\n    const newGrid = updateGrid(this.state.grid, row, col);\n    const newNodes = updateNodes(this.state.nodes, row, col);\n    this.setState({grid: newGrid, nodes: newNodes});\n  }\n\n  onMouseUp() {\n    this.setState({mouseDown: false});\n  }\n\n  animateSearch(visited, path) {\n    if(visited === false){\n      console.log(\"No path found.\")\n      this.algoFinished = true;\n      document.getElementById(\"startButton\").disabled = false;\n      document.getElementById(\"clearGridButton\").disabled = false;\n    }\n    for (let i = 0; i <= visited.length; i++) {\n      if (i === visited.length) {\n        setTimeout(() => {\n          this.animatePath(path);\n        }, 10 * i);\n        return;\n      }\n      // Visited nodes get animated in 10ms intervals\n      setTimeout(() => {\n        const node = visited[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-visited';\n      }, 10 * i);\n    }\n  }\n\n  animatePath(path) {\n    for (let i = 0; i < path.length; i++) {\n      setTimeout(() => {\n        const node = path[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-shortest-path';\n      }, 35 * i);\n    }\n    this.algoFinished = true;\n    document.getElementById(\"startButton\").disabled = false;\n    document.getElementById(\"clearGridButton\").disabled = false;\n  }\n\n  visualizeSearch() {\n      const algo = document.getElementById(\"startButton\").innerHTML;\n      document.getElementById(\"startButton\").disabled = true;\n      document.getElementById(\"clearGridButton\").disabled = true;\n      console.log(algo);\n      this.algoFinished = false;\n      const {grid, nodes} = this.state;\n      const start = grid[START_NODE_ROW][START_NODE_COL];\n      const goal = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n      var visited = [];\n      var path = [];\n      // Select algo based on start button text\n      if(algo === \"A* Search\"){\n        console.log(nodes)\n        // console.log(\"start:\", start)\n        // console.log(\"start-id:\", start.id)\n        // console.log(\"goal:\", goal)\n        visited = astar(nodes, start, goal, visited, grid, []);\n        path = getAstarPath(goal);\n        console.log(\"Visited:\", visited);\n        console.log(\"Path:\", path);\n        this.animateSearch(visited, path);\n      }\n      else if(algo === \"Dijkstra's Algorithm\"){\n        visited = dijkstra(grid, start, goal);\n        path = getPath(goal);\n        this.animateSearch(visited, path);\n      }\n  }\n\n  clearGrid() {\n    if(this.algoFinished){\n      const board = this.initGrid();\n      this.setState({grid: board[0], nodes: board[1]});\n      for(let row = 0; row < 20; row++) {\n        for (let col = 0; col < 50; col++) {\n          if(row === START_NODE_ROW && col === START_NODE_COL){\n            //this.nodes[this.start].status = \"start\"\n            document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n          }\n          else if(row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\n            document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n            //this.target.status = \"target\";\n          }\n          else{\n            //this.nodes[`${row}-${col}`].status = \"unvisited\";\n            document.getElementById(`node-${row}-${col}`).className = 'node';\n          }\n        }\n      }\n    }\n  }\n  // Initialize New Grid\n  initGrid = () => {\n    var grid = [];\n    var nodes = {};\n    for (let row = 0; row < 20; row++) {\n      const tmpRow = [];\n      for (let col = 0; col < 50; col++) {\n        var nodeId = `${row}-${col}`, nodeClass, node;\n        var node = newNode(col, row);\n\n        if(row === START_NODE_ROW && col === START_NODE_COL){\n          node.status = \"start\"\n        } \n        else if(row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\n          node.status = \"target\"\n        } \n        else node.status = \"node\"\n\n        tmpRow.push(node);\n        nodes[nodeId] = node;\n      }\n      grid.push(tmpRow);\n    }\n    return [grid, nodes];\n  };\n\n  render() {\n    const {grid, mouseDown, algoFinished} = this.state;\n    let tableHTML = \"\";\n    return (\n      <>\n        \n        <div class=\"board\">\n        <div class=\"center\">\n          <button id=\"startButton\" onClick={() => this.visualizeSearch()}>Visualize Algorithm</button>\n        </div>\n        <div class=\"center\">\n          <button id=\"clearGridButton\" onClick={() => this.clearGrid()}>Clear Grid</button>\n        </div>\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const {row, col, isFinish, isStart, isWall} = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      g = {Infinity}\n                      h = {null}\n                      f = {Infinity}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      mouseDown={mouseDown}\n                      onMouseDown={(row, col) => this.onMouseDown(row, col)}\n                      onMouseEnter={(row, col) => this.onMouseEnter(row, col)}\n                      onMouseUp={() => this.onMouseUp()}\n                      row={row}></Node>\n                      \n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n        </div>\n      </>\n    );\n  }\n}\n\n// Create a new Node\nconst newNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    g: Infinity,\n    h: null,\n    f: Infinity,\n    status: null,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n    weight: 0,\n    id: `${row}-${col}`\n  };\n};\n\n// Update our grid state\nconst updateGrid = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  if(row === START_NODE_ROW && col === START_NODE_COL \n    || row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\n    return grid;\n  }\n  const newNode = {\n    ...node,\n   isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst updateNodes = (nodes, row, col) => {\n  if(row === START_NODE_ROW && col === START_NODE_COL \n    || row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\n    return nodes;\n  }\n  const newNodes = nodes;\n  const node = nodes[`${row}-${col}`];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  if(newNode.isWall) newNode.status = \"wall\";\n  newNodes[`${row}-${col}`] = newNode;\n  return newNodes;\n}","import React, {Component} from 'react';\nimport './navbar.css';\n\nexport default class Navbar extends Component{\n\n    constructor(props){\n        super(props);\n        this.state = {value: props.value};\n    }\n\n    handleChange(event){\n        this.setState({value: event.target.value});\n    }\n    \n    toggleDropdown(){\n        \n        document.getElementById(\"myDropdown\").classList.toggle(\"show\");\n    }\n\n    selectAlgo(id){\n        this.toggleDropdown();\n        document.getElementById(\"startButton\").innerHTML = id;\n        return;\n    }\n\n    render(){\n        return(\n            <div class=\"navbar\">\n                <div class=\"dropdown\">\n                    <button onClick={() => this.toggleDropdown()} class=\"dropbtn\">Select an Algorithm</button>\n                    <div id=\"myDropdown\" class=\"dropdown-content\">\n                        <a href=\"#\" id=\"dijkstraStart\" onClick={() => this.selectAlgo(\"Dijkstra's Algorithm\")}>Dijkstra's Algorithm</a>\n                        <a href=\"#\" id=\"astarStart\" onClick={() => this.selectAlgo(\"A* Search\")}>A* Search</a>\n                        <a href=\"#\" id=\"bfsStart\" onClick={() => this.selectAlgo(\"Breadth-First-Search\")}>BFS</a>\n                        <a href=\"#\" id=\"dfsStart\" onClick={() => this.selectAlgo(\"Depth-First-Search\")}>DFS</a>\n                    </div>\n                </div>\n            </div>\n        )\n    }\n\n}    \n// Close the dropdown menu if the user clicks outside of it\nwindow.onclick = function(event) {\n    if (!event.target.matches('.dropbtn')) {\n    var dropdowns = document.getElementsByClassName(\"dropdown-content\");\n    var i;\n    for (i = 0; i < dropdowns.length; i++) {\n        var openDropdown = dropdowns[i];\n        if (openDropdown.classList.contains('show')) {\n        openDropdown.classList.remove('show');\n        }\n    }\n    }\n}","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './pathfindingVisualizer/pathfindingVisualizer';\nimport Navbar from './navbar';\n\nfunction App() {\n  return (    \n    <div className=\"App\">\n      <Navbar></Navbar>\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div> \n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));"],"sourceRoot":""}