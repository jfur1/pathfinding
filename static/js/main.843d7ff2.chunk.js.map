{"version":3,"sources":["pathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.js","algorithms/astar.js","pathfindingVisualizer/pathfindingVisualizer.jsx","algorithms/dfs.js","algorithms/bfs.js","navbar.jsx","App.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","type","g","h","f","direction","weight","status","id","className","Component","dijkstra","grid","start","goal","visited","frontier","nodes","node","push","getNodes","length","sortNodes","shift","Infinity","isVisited","updateNeighborCosts","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getNeighbors","previousNode","getPath","path","tmpNode","unshift","closestNode","index","i","splice","updateNeighbors","target","heuristic","coords","split","x","parseInt","y","toString","updateNode","tmpTarget","trueStart","trueTarget","startCoords","targetCoords","nodeAx","nodeAy","nodeBx","nodeBy","getPathCost","nodeAcoords","map","nodeBcoords","delta_x","Math","abs","delta_y","manhattanDistance","dist","PathfindingVisualizer","initGrid","tmpRow","nodeId","newNode","state","mouseDown","algoFinished","currentAlgo","board","setState","updateBoard","console","log","document","getElementById","disabled","setTimeout","animatePath","algo","innerHTML","clearGrid","explored","Object","keys","astar","getAstarPath","animateSearch","stack","pop","nextNode","dfs","bfs","class","onClick","visualizeSearch","rowIdx","nodeIdx","newGrid","slice","newNodes","Navbar","value","event","classList","toggle","algoName","toggleDropdown","href","selectAlgo","window","onclick","matches","dropdowns","getElementsByClassName","openDropdown","contains","remove","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.843d7ff2.chunk.js","sourcesContent":["import React, {Component} from 'react';\nimport './Node.css';\n\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      row,\n      g,\n      h,\n      f,\n      direction,\n      weight,\n      status\n    } = this.props;\n    const type = isFinish\n      ? 'node-finish'\n      : isStart\n      ? 'node-start'\n      : isWall\n      ? 'node-wall'\n      : '';\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${type}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}></div>\n    );\n  }\n}","// Dijkstra's Algorithm:\n//  - Inputs:\n//      - 2D Grid Matrix\n//      - Start Node\n//      - Goal Node\n//  - Output:\n//      - List of nodes representing the shortest possible path, if one exists.\n\nexport function dijkstra(grid, start, goal) {\n    const visited = [];\n    start.g = 0;\n    const frontier = getNodes(grid);\n    while (!!frontier.length) {\n      sortNodes(frontier);\n      // Guarenteed to be next closest node since we've just sorted the unvisited nodes by distance\n      const node = frontier.shift();\n      \n      // Skip checks for any walls\n      if (node.isWall) continue;\n      // If the closest node is infinite distance, then no path exists to our goal\n      if (node.g === Infinity) return visited;\n\n      node.isVisited = true;\n      visited.push(node);\n      if (node === goal) return visited;\n      updateNeighborCosts(node, grid);\n    }\n  }\n  \n  // Sort the nodes by distance\n  function sortNodes(frontier) {\n    frontier.sort((nodeA, nodeB) => nodeA.g - nodeB.g);\n  }\n  \n  function updateNeighborCosts(node, grid) {\n    const unvisitedNeighbors = getNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n      neighbor.g = node.g + 1;\n      neighbor.previousNode = node;\n    }\n  }\n  \n  function getNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n  }\n  \n  function getNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        nodes.push(node);\n      }\n    }\n    return nodes;\n  }\n  \n  // Backtracks from the goal to find the shortest path.\n\n  export function getPath(goal) {\n    const path = [];\n    let tmpNode = goal;\n    while (tmpNode !== null) {\n      path.unshift(tmpNode);\n      tmpNode = tmpNode.previousNode;\n    }\n    return path;\n  }","// A* Search Algorithm\n//  - Allowable Moves: [N, E, S, W]\n//  - Inputs\n//      - Adjacency Matrix\n//      - Start Node\n//      - Goal Node\n//  - Output:\n//      - Guarenteed shortest possible path\nexport function astar(nodes, start, goal, explored, grid, heuristic){\n    if(!start || !goal || start === goal)\n        return false;\n    nodes[start.id].g = 0;\n    nodes[start.id].f = 0;\n    nodes[start.id].direction = \"N\";\n    let frontier = Object.keys(nodes);\n    console.log(\"frontier:\", frontier)\n    while(frontier.length){\n        // Pop the next closest node off the frontier\n        let node = closestNode(nodes, frontier);\n        // Make sure the node is not a wall\n        while(node.status === \"wall\"  && frontier.length){\n            node = closestNode(nodes, frontier);\n        }\n        if(node.g === Infinity) return false;\n        explored.push(node);\n        node.status = \"visited\";\n        if(node.id === goal.id) return explored;\n\n        updateNeighbors(nodes, node, grid, start, goal, heuristic);\n\n    }\n    \n}\n\nfunction closestNode(nodes, frontier){\n    let node, index;\n    for(let i = 0; i < frontier.length; i++){\n        if(!node || node.f > nodes[frontier[i]].f){\n            node = nodes[frontier[i]];\n            index = i;\n        }\n        else if(node.f === nodes[frontier[i]].f){\n            if(node.h > nodes[frontier[i]].h){\n                node = nodes[frontier[i]];\n                index = i;\n            }\n        }\n    }\n    frontier.splice(index, 1);\n    return node;\n}\n\nfunction updateNeighbors(nodes, node, grid, start, target, heuristic){\n    let neighbors = getNeighbors(node.id, nodes, grid);\n    for(let neighbor of neighbors){\n        if(target){\n            // console.log(\"node:\", node);\n            // console.log(\"neighbor:\", neighbor)\n            updateNode(node, nodes[neighbor], nodes[start.id], nodes[target.id], nodes, grid, heuristic);\n        }\n        else{\n            updateNode(node, nodes[neighbor]);\n        }\n    }\n}\n\nfunction updateNode(node, tmpTarget, trueStart, trueTarget, nodes, grid, heuristic){\n    let path = getPathCost(node, tmpTarget);\n    // If our new target node has no heuristic => Assign to be manhattan distance\n    if(!tmpTarget.h) tmpTarget.h = manhattanDistance(tmpTarget, trueTarget);\n    let dist = node.g + tmpTarget.weight + path[0];\n    if(dist < tmpTarget.g){\n        tmpTarget.g = dist;\n        tmpTarget.f = tmpTarget.g + tmpTarget.h\n        tmpTarget.previousNode = node;\n        tmpTarget.path = path[1];\n        tmpTarget.direction = path[2];\n    }\n}\n\nfunction getNeighbors(id, nodes, grid){\n    let coords = id.split(\"-\");\n    let x = parseInt(coords[0]);\n    let y = parseInt(coords[1]);\n    let neighbors = [];\n    let neighbor;\n    // North\n    if(grid[x-1] && grid[x-1][y]){\n        neighbor = `${(x-1).toString()}-${y.toString()}`;\n        if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n    }\n    // South\n    if(grid[x+1] && grid[x+1][y]){\n        neighbor = `${(x+1).toString()}-${y.toString()}`;\n        if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n    }\n    if(grid[x][y-1]){\n        neighbor = `${x.toString()}-${(y - 1).toString()}`;\n        if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n    }\n    if(grid[x][y+1]){\n        neighbor = `${x.toString()}-${(y + 1).toString()}`;\n        if(nodes[neighbor].status !== \"wall\") neighbors.push(neighbor);\n    }\n    return neighbors;\n}\n\nfunction getPathCost(nodeA, nodeB){\n    let startCoords = nodeA.id.split(\"-\");\n    let targetCoords = nodeB.id.split(\"-\");\n    let nodeAx = parseInt(startCoords[0]);\n    let nodeAy = parseInt(startCoords[1]);\n    let nodeBx = parseInt(targetCoords[0]);\n    let nodeBy = parseInt(targetCoords[1]);\n    // B is above A\n    if(nodeBx < nodeAx && nodeAy === nodeBy){\n        if(nodeA.direction === \"N\") return [1, [\"f\"], \"N\"];\n        else if(nodeA.direction === \"E\") return [2, [\"l\", \"f\"], \"N\"];\n        else if(nodeA.direction === \"W\") return [2, [\"r\", \"f\"], \"N\"];\n        else if(nodeA.direction === \"S\") return [3, [\"r\", \"r\", \"f\"], \"N\"];\n        else if(nodeA.direction === \"NE\") return [1.5, null, \"N\"];\n        else if(nodeA.direction === \"SE\") return [2.5, null, \"N\"];\n        else if(nodeA.direction === \"NW\") return [1.5, null, \"N\"];\n        else if(nodeA.direction === \"SW\") return [2.5, null, \"N\"];\n    }\n    else if(nodeBx > nodeAx && nodeAy === nodeBy){\n        if(nodeA.direction === \"N\") return [3, [\"r\", \"r\", \"f\"], \"S\"];\n        else if(nodeA.direction === \"E\") return [2, [\"r\", \"f\"], \"S\"];\n        else if(nodeA.direction === \"W\") return [2, [\"l\", \"f\"], \"S\"];\n        else if(nodeA.direction === \"S\") return [1, [\"f\"], \"S\"];\n        else if(nodeA.direction === \"NE\") return [2.5, null, \"S\"];\n        else if(nodeA.direction === \"SE\") return [1.5, null, \"S\"];\n        else if(nodeA.direction === \"NW\") return [2.5, null, \"S\"];\n        else if(nodeA.direction === \"SW\") return [1.5, null, \"S\"];\n    }\n    if(nodeBy < nodeAy && nodeAx === nodeBx){\n        if(nodeA.direction === \"N\") return [2, [\"l\", \"f\"], \"W\"];\n        else if(nodeA.direction === \"E\") return [3, [\"l\", \"l\", \"f\"], \"W\"];\n        else if(nodeA.direction === \"W\") return [1, [\"f\"], \"W\"];\n        else if(nodeA.direction === \"S\") return [2, [\"r\", \"f\"], \"W\"];\n        else if(nodeA.direction === \"NE\") return [2.5, null, \"W\"];\n        else if(nodeA.direction === \"SE\") return [2.5, null, \"W\"];\n        else if(nodeA.direction === \"NW\") return [1.5, null, \"W\"];\n        else if(nodeA.direction === \"SW\") return [1.5, null, \"W\"];\n    }\n    else if(nodeBy > nodeAy && nodeAx === nodeBx){\n        if(nodeA.direction === \"N\") return [2, [\"r\", \"f\"], \"E\"];\n        else if(nodeA.direction === \"E\") return [1, [\"f\"], \"E\"];\n        else if(nodeA.direction === \"W\") return [3, [\"r\",\"r\",\"f\"], \"E\"];\n        else if(nodeA.direction === \"S\") return [2, [\"l\", \"f\"], \"E\"];\n        else if(nodeA.direction === \"NE\") return [1.5, null, \"E\"];\n        else if(nodeA.direction === \"SE\") return [1.5, null, \"E\"];\n        else if(nodeA.direction === \"NW\") return [2.5, null, \"E\"];\n        else if(nodeA.direction === \"SW\") return [2.5, null, \"E\"];\n    }\n}\n\nfunction manhattanDistance(nodeA, nodeB){\n    let nodeAcoords = nodeA.id.split(\"-\").map(x => parseInt(x));\n    let nodeBcoords = nodeB.id.split(\"-\").map(x => parseInt(x));\n    let nodeAx = nodeAcoords[0];\n    let nodeBx = nodeBcoords[0];\n    let nodeAy = nodeAcoords[1];\n    let nodeBy = nodeBcoords[1];\n\n    let delta_x = Math.abs(nodeAx - nodeBx);\n    let delta_y = Math.abs(nodeAy - nodeBy);\n\n    return (delta_x + delta_y);\n}\n\nexport function getAstarPath(goal) {\n    const path = [];\n    let tmpNode = goal;\n    while (tmpNode !== null) {\n      path.unshift(tmpNode);\n      tmpNode = tmpNode.previousNode;\n    }\n    return path;\n  }","import React, {Component} from 'react';\nimport Node from './Node/Node';\nimport {dijkstra, getPath} from '../algorithms/dijkstra';\nimport {astar, getAstarPath} from '../algorithms/astar';\nimport './pathfindingVisualizer.css';\nimport {dfs} from '../algorithms/dfs';\nimport { bfs } from '../algorithms/bfs';\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35;\n\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      nodes: {},\n      mouseDown: false,\n      algoFinished: true,\n      currentAlgo: null,\n      start: null,\n      target: null\n    };\n  }\n\n  componentDidMount() {\n    const board = this.initGrid();\n    this.setState({grid: board[0], nodes: board[1]});\n  }\n\n  onMouseDown(row, col) {\n    // const newGrid = updateGrid(this.state.grid, row, col);\n    // const newNodes = updateNodes(this.state.nodes, row, col);\n    const board = updateBoard(this.state.grid, this.state.nodes, row, col);\n    this.setState({grid: board[0], nodes: board[1], mouseDown: true});\n  }\n\n  onMouseEnter(row, col) {\n    if (!this.state.mouseDown) return;\n    // const newGrid = updateGrid(this.state.grid, row, col);\n    // const newNodes = updateNodes(this.state.nodes, row, col);\n    const board = updateBoard(this.state.grid, this.state.nodes, row, col);\n    this.setState({grid: board[0], nodes: board[1]});\n  }\n\n  onMouseUp() {\n    this.setState({mouseDown: false});\n  }\n\n  animateSearch(visited, path) {\n    if(visited === false || path.length === 1 || visited.length === 1){\n      console.log(\"No path found.\")\n      this.algoFinished = true;\n      document.getElementById(\"startButton\").disabled = false;\n      document.getElementById(\"clearGridButton\").disabled = false;\n    }else{\n        for (let i = 0; i <= visited.length; i++) {\n          if (i === visited.length) {\n            setTimeout(() => {\n              this.animatePath(path);\n            }, 10 * i);\n            return;\n          }\n          // Visited nodes get animated in 10ms intervals\n          setTimeout(() => {\n            const node = visited[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n              'node node-visited';\n          }, 10 * i);\n        }\n      }\n    }\n\n  animatePath(path) {\n    for (let i = 0; i < path.length; i++) {\n      setTimeout(() => {\n        const node = path[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-shortest-path';\n      }, 25 * i);\n    }\n    this.algoFinished = true;\n    document.getElementById(\"startButton\").disabled = false;\n    document.getElementById(\"clearGridButton\").disabled = false;\n  }\n\n  visualizeSearch() {\n      const algo = document.getElementById(\"startButton\").innerHTML;\n      if(algo === \"Visualize Algorithm\"){\n        console.log(\"Select an algorithm!\");\n      }\n      else{\n        console.log(\"Selected Algorithm:\", algo);\n        // Clear any visited nodes from the grid\n        this.clearGrid();\n        document.getElementById(\"startButton\").disabled = true;\n        document.getElementById(\"clearGridButton\").disabled = true;\n        this.algoFinished = false;\n\n        const {grid, nodes} = this.state;\n        var start = grid[START_NODE_ROW][START_NODE_COL];\n        var goal = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n        var visited = [];\n        var path = [];\n        // Select algo based on start button text\n        if(algo === \"A* Search\"){\n          console.log(nodes);\n          // console.log(\"start:\", start)\n          // console.log(\"start-id:\", start.id)\n          // console.log(\"goal:\", goal)\n          visited = astar(nodes, start, goal, visited, grid, []);\n          path = getAstarPath(goal);\n          console.log(\"Astar Visited:\", visited);\n          console.log(\"Astar Path:\", path);\n          this.animateSearch(visited, path);\n        }\n        else if(algo === \"Dijkstra's Algorithm\"){\n          visited = dijkstra(grid, start, goal);\n          path = getPath(goal);\n          console.log(\"Dijkstra Visited:\", visited);\n          console.log(\"Dijkstra Path:\", path);\n          this.animateSearch(visited, path);\n        }else if(algo === \"Depth-First-Search\"){\n          visited = dfs(grid, start, goal);\n          path = getPath(goal);\n          console.log(\"DFS Visited:\", visited);\n          console.log(\"DFS Path:\", path);\n          this.animateSearch(visited, path);\n        }else if(algo === \"Breadth-First-Search\"){\n          visited = bfs(grid, start, goal);\n          path = getPath(goal);\n          console.log(\"BFS Visited:\", visited);\n          console.log(\"BFS Path:\", path);\n          this.animateSearch(visited, path);\n        }\n      }\n  }\n  // Same as init grid, exept walls & start/goal nodes are kept\n  clearGrid() {\n    if(this.algoFinished){\n      for(let row = 0; row < 20; row++) {\n        for (let col = 0; col < 50; col++) {\n\n          if(row === START_NODE_ROW && col === START_NODE_COL){\n            document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n          }\n          else if(row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\n            document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n          }\n          else if(document.getElementById(`node-${row}-${col}`).className !== \"node node-wall\"){\n            document.getElementById(`node-${row}-${col}`).className = 'node';\n            this.state.grid[row][col].previousNode = null;\n            this.state.grid[row][col].isVisited = false;\n          }\n        }\n      }\n    }\n  }\n  // Initialize New Grid\n  initGrid = () => {\n    var grid = [];\n    var nodes = {};\n    for (let row = 0; row < 20; row++) {\n      const tmpRow = [];\n      for (let col = 0; col < 50; col++) {\n        var nodeId = `${row}-${col}`, nodeClass, node;\n        var node = newNode(col, row);\n\n        if(row === START_NODE_ROW && col === START_NODE_COL){\n          node.status = \"start\"\n        } \n        else if(row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\n          node.status = \"target\"\n        } \n        else node.status = \"node\"\n\n        tmpRow.push(node);\n        nodes[nodeId] = node;\n      }\n      grid.push(tmpRow);\n    }\n    return [grid, nodes];\n  };\n\n  render() {\n    const {grid, mouseDown, algoFinished} = this.state;\n    let tableHTML = \"\";\n    return (\n      <>\n        <div class=\"board\">\n        <div class=\"center\">\n          <button id=\"startButton\" onClick={() => this.visualizeSearch()}>Visualize Algorithm</button>\n        </div>\n        <div class=\"center\">\n          <button id=\"clearGridButton\" onClick={() => this.initGrid()}>Reset Grid</button>\n        </div>\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const {row, col, isFinish, isStart, isWall} = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      g = {Infinity}\n                      h = {null}\n                      f = {Infinity}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      mouseDown={mouseDown}\n                      onMouseDown={(row, col) => this.onMouseDown(row, col)}\n                      onMouseEnter={(row, col) => this.onMouseEnter(row, col)}\n                      onMouseUp={() => this.onMouseUp()}\n                      row={row}></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n        </div>\n      </>\n    );\n  }\n}\n// Create a new Node\nconst newNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    g: Infinity,\n    h: null,\n    f: Infinity,\n    status: null,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n    weight: 0,\n    id: `${row}-${col}`\n  };\n};\n// Update our grid state\nconst updateBoard = (grid, nodes, row, col) => {\n  // Create copies of grid & nodes\n  const newGrid = grid.slice();\n  const newNodes = nodes;\n  // If start/goal node, continue\n  if(row === START_NODE_ROW && col === START_NODE_COL \n    || row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\n    return [grid, nodes];\n  }\n  // Get the node in question\n  const node = newGrid[row][col];\n  // Create a new node with prop \"isWall\" toggled\n  const newNode = {\n    ...node,\n   isWall: !node.isWall,\n  };\n  // Set status to wall if .isWall === true\n  if(newNode.isWall) newNode.status = \"wall\";\n  else newNode.status = \"node\";\n  // Update the new node in the grid & nodes sets, then return to be updated as state\n  newNodes[`${row}-${col}`] = newNode;\n  newGrid[row][col] = newNode;\n\n  return [newGrid, newNodes];\n};","export function dfs(grid, start, goal){\n    const visited = [];\n    let stack = [start];\n    while(stack.length){\n        const node = stack.pop();\n        if(node.id === goal.id) return visited;\n\n        if(!node.isWall && (node.isStart || !node.isVisited)){\n            node.isVisited = true;\n            visited.push(node);\n            const {col, row} = node;\n            let nextNode;\n            if(row > 0){\n                nextNode = grid[row-1][col];\n                if(!nextNode.isVisited){\n                    nextNode.previousNode = node;\n                    stack.push(nextNode);\n                }\n            }\n            if(row < grid.length - 1){\n                nextNode = grid[row+1][col];\n                if(!nextNode.isVisited){\n                    nextNode.previousNode = node;\n                    stack.push(nextNode);\n                }\n            }\n            if(col > 0){\n                nextNode = grid[row][col-1];\n                if(!nextNode.isVisited){\n                    nextNode.previousNode = node;\n                    stack.push(nextNode);\n                }\n            }\n            if(col < grid[0].length-1){\n                nextNode = grid[row][col+1];\n                if(!nextNode.isVisited){\n                    nextNode.previousNode = node;\n                    stack.push(nextNode);\n                }\n            }\n        }\n    }\n    return visited;\n}","export function bfs(grid, start, goal){\n    const visited = [];\n    let stack = [start];\n    while(stack.length){\n        const node = stack.shift();\n        if(node.id === goal.id) return visited;\n\n        if(!node.isWall && (node.isStart || !node.isVisited)){\n            node.isVisited = true;\n            visited.push(node);\n            const {col, row} = node;\n            let nextNode;\n            if(row > 0){\n                nextNode = grid[row-1][col];\n                if(!nextNode.isVisited){\n                    nextNode.previousNode = node;\n                    stack.push(nextNode);\n                }\n            }\n            if(row < grid.length - 1){\n                nextNode = grid[row+1][col];\n                if(!nextNode.isVisited){\n                    nextNode.previousNode = node;\n                    stack.push(nextNode);\n                }\n            }\n            if(col > 0){\n                nextNode = grid[row][col-1];\n                if(!nextNode.isVisited){\n                    nextNode.previousNode = node;\n                    stack.push(nextNode);\n                }\n            }\n            if(col < grid[0].length-1){\n                nextNode = grid[row][col+1];\n                if(!nextNode.isVisited){\n                    nextNode.previousNode = node;\n                    stack.push(nextNode);\n                }\n            }\n        }\n    }\n    return visited;\n}","import React, {Component} from 'react';\nimport './navbar.css';\n\nexport default class Navbar extends Component{\n\n    constructor(props){\n        super(props);\n        this.state = {value: props.value};\n    }\n\n    handleChange(event){\n        this.setState({value: event.target.value});\n    }\n    \n    toggleDropdown(){\n        document.getElementById(\"myDropdown\").classList.toggle(\"show\");\n    }\n\n    selectAlgo(algoName){\n        this.toggleDropdown();\n        document.getElementById(\"startButton\").innerHTML = algoName;\n    }\n\n    render(){\n        return(\n            <div class=\"navbar\">\n                <div class=\"dropdown\">\n                    <button onClick={() => this.toggleDropdown()} class=\"dropbtn\">Select an Algorithm</button>\n                    <div id=\"myDropdown\" class=\"dropdown-content\">\n                        <a href=\"#\" id=\"dijkstraStart\" onClick={() => this.selectAlgo(\"Dijkstra's Algorithm\")}>Dijkstra's Algorithm</a>\n                        <a href=\"#\" id=\"astarStart\" onClick={() => this.selectAlgo(\"A* Search\")}>A* Search</a>\n                        <a href=\"#\" id=\"bfsStart\" onClick={() => this.selectAlgo(\"Breadth-First-Search\")}>BFS</a>\n                        <a href=\"#\" id=\"dfsStart\" onClick={() => this.selectAlgo(\"Depth-First-Search\")}>DFS</a>\n                    </div>\n                </div>\n            </div>\n        )\n    }\n\n}    \n// Close the dropdown menu if the user clicks outside of it\nwindow.onclick = function(event) {\n    if (!event.target.matches('.dropbtn')) {\n    var dropdowns = document.getElementsByClassName(\"dropdown-content\");\n    var i;\n    for (i = 0; i < dropdowns.length; i++) {\n        var openDropdown = dropdowns[i];\n        if (openDropdown.classList.contains('show')) {\n        openDropdown.classList.remove('show');\n        }\n    }\n    }\n}","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './pathfindingVisualizer/pathfindingVisualizer';\nimport Navbar from './navbar';\n\nfunction App() {\n  return (    \n    <div className=\"App\">\n      <Navbar></Navbar>\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div> \n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));"],"sourceRoot":""}